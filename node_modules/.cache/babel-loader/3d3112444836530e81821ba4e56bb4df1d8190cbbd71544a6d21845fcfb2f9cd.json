{"ast":null,"code":"// Decryption.js\n/*import { useState } from \"react\";\r\nimport ToBits from \"./ToBits\";\r\nimport { decryptData } from './ToBlackBox';\r\n\r\nconst HEADER_BITS = [1, 0, 1, 0, 1, 0, 1, 1];\r\n\r\nfunction bitArrayToString(bits) {\r\n\tconst bytes = [];\r\n\tfor (let i = 0; i < bits.length; i += 8) {\r\n\t\tlet byte = 0;\r\n\t\tfor (let j = 0; j < 8; j++) {\r\n\t\t\tbyte = (byte << 1) | (bits[i + j] || 0);\r\n\t\t}\r\n\t\tbytes.push(byte);\r\n\t}\r\n\tconst decoder = new TextDecoder('utf-8');\r\n\treturn decoder.decode(new Uint8Array(bytes));\r\n}\r\n\r\nfunction bitArrayToUint8Array(bits) {\r\n\tconst bytes = [];\r\n\tfor (let i = 0; i < bits.length; i += 8) {\r\n\t\tlet byte = 0;\r\n\t\tfor (let j = 0; j < 8; j++) {\r\n\t\t\tbyte = (byte << 1) | (bits[i + j] || 0);\r\n\t\t}\r\n\t\tbytes.push(byte);\r\n\t}\r\n\treturn new Uint8Array(bytes);\r\n}\r\n\r\nfunction base64ToUint8Array(base64) {\r\n\treturn Uint8Array.from(atob(base64), c => c.charCodeAt(0));\r\n}\r\n\r\nexport default function Decryption() {\r\n\tconst [gifFile, setGifFile] = useState(null);\r\n\tconst [frames, setFrames] = useState([]);\r\n\tconst [error, setError] = useState(null);\r\n\tconst [password, setPassword] = useState(\"\");\r\n\r\n\tconst handleGIFChange = (e) => {\r\n\t\tconst file = e.target.files[0];\r\n\t\tif (!file) return;\r\n\t\tsetGifFile(file);\r\n\r\n\t\tToBits(file)\r\n\t\t\t.then(({ frames }) => setFrames(frames))\r\n\t\t\t.catch(err => setError(err.message));\r\n\t};\r\n\r\n\tconst handleExtractBinary = async () => {\r\n\t\tif (!frames.length) return;\r\n\t\tif (!password) {\r\n\t\t\tsetError(\"Password is required\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst allBits = [];\r\n\t\tfor (let frameIndex = 0; frameIndex < frames.length; frameIndex++) {\r\n\t\t\tconst patch = frames[frameIndex].patch;\r\n\t\t\tfor (let i = 0; i < patch.length; i += 4) {\r\n\t\t\t\tallBits.push(patch[i + 2] & 1); // LSB of blue channel\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Check header\r\n\t\tfor (let i = 0; i < HEADER_BITS.length; i++) {\r\n\t\t\tif (allBits[i] !== HEADER_BITS[i]) {\r\n\t\t\t\tsetError(\"Header not found in GIF.\");\r\n\t\t\t\tconsole.warn(\"Header read:\", allBits.slice(0, HEADER_BITS.length));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Extract metadata length\r\n\t\tconst metadataLengthBits = allBits.slice(HEADER_BITS.length, HEADER_BITS.length + 32);\r\n\t\tconst metadataLength = parseInt(metadataLengthBits.join(''), 2);\r\n\r\n\t\t// Extract metadata and payload\r\n\t\tconst metadataBits = allBits.slice(HEADER_BITS.length + 32, HEADER_BITS.length + 32 + metadataLength);\r\n\t\tconst payloadBits = allBits.slice(HEADER_BITS.length + 32 + metadataLength);\r\n\r\n\t\t// Convert metadata bits to string\r\n\t\tconst metadataText = bitArrayToString(metadataBits);\r\n\r\n\t\t// Now metadataText should be valid JSON if ToBinary stored Base64 IV/salt\r\n\t\tlet metadata;\r\n\t\ttry {\r\n\t\t\tmetadata = JSON.parse(metadataText);\r\n\t\t} catch (err) {\r\n\t\t\tconsole.error(\"Failed to parse metadata JSON:\", err);\r\n\t\t\tconsole.log(\"Metadata text:\", metadataText); // <-- inspect raw string\r\n\t\t\tsetError(\"Failed to parse metadata JSON.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconsole.log(\"Raw metadata text:\", metadataText);\r\n\r\n\t\t// Convert payload bits to Uint8Array ready for decryption\r\n\t\tconst encryptedBytes = bitArrayToUint8Array(payloadBits);\r\n\t\tconsole.log(\"Encrypted payload length:\", encryptedBytes.length);\r\n\r\n\t\t// Decode IV and salt for decryption\r\n\t\tconst ivArray = base64ToUint8Array(metadata.iv);\r\n\t\tconst saltArray = base64ToUint8Array(metadata.salt);\r\n\t\tconsole.log(\"IV:\", ivArray);\r\n\t\tconsole.log(\"Salt:\", saltArray);\r\n\r\n\r\n\t\tconst ivBuffer = ivArray.buffer;\r\n\t\tconst saltBuffer = saltArray.buffer;\r\n\t\tconsole.log(\"IV:\", ivBuffer);\r\n\t\tconsole.log(\"Salt:\", saltBuffer);\r\n\r\n\t\ttry {\r\n\t\t\tconst decryptedData = await decryptData(encryptedBytes, password, ivBuffer, saltBuffer);\r\n\t\t\tconsole.log(\"Decrypted data:\", decryptedData);\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error(\"Decryption failed:\", error);\r\n\t\t\tsetError(\"Decryption failed. Check password and try again.\");\r\n\t\t}\r\n\t};\r\n\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t<h2>Decrypt GIF Binary Data</h2>\r\n\t\t\t<input type=\"file\" accept=\"image/gif\" onChange={handleGIFChange} />\r\n\t\t\t{gifFile && <p>Uploaded GIF: {gifFile.name}</p>}\r\n\t\t\t<input type=\"password\" placeholder=\"Password\" value={password} onChange={(e) => setPassword(e.target.value)} />\r\n\t\t\t{frames.length > 0 && <button onClick={handleExtractBinary}>Extract Binary Data</button>}\r\n\t\t\t{error && <p className=\"error\">{error}</p>}\r\n\t\t</div>\r\n\t);\r\n}*/","map":{"version":3,"names":[],"sources":["C:/Users/mesco/OneDrive/Documents/GitHub/S/src/components/Decryption.js"],"sourcesContent":["// Decryption.js\r\n/*import { useState } from \"react\";\r\nimport ToBits from \"./ToBits\";\r\nimport { decryptData } from './ToBlackBox';\r\n\r\nconst HEADER_BITS = [1, 0, 1, 0, 1, 0, 1, 1];\r\n\r\nfunction bitArrayToString(bits) {\r\n\tconst bytes = [];\r\n\tfor (let i = 0; i < bits.length; i += 8) {\r\n\t\tlet byte = 0;\r\n\t\tfor (let j = 0; j < 8; j++) {\r\n\t\t\tbyte = (byte << 1) | (bits[i + j] || 0);\r\n\t\t}\r\n\t\tbytes.push(byte);\r\n\t}\r\n\tconst decoder = new TextDecoder('utf-8');\r\n\treturn decoder.decode(new Uint8Array(bytes));\r\n}\r\n\r\nfunction bitArrayToUint8Array(bits) {\r\n\tconst bytes = [];\r\n\tfor (let i = 0; i < bits.length; i += 8) {\r\n\t\tlet byte = 0;\r\n\t\tfor (let j = 0; j < 8; j++) {\r\n\t\t\tbyte = (byte << 1) | (bits[i + j] || 0);\r\n\t\t}\r\n\t\tbytes.push(byte);\r\n\t}\r\n\treturn new Uint8Array(bytes);\r\n}\r\n\r\nfunction base64ToUint8Array(base64) {\r\n\treturn Uint8Array.from(atob(base64), c => c.charCodeAt(0));\r\n}\r\n\r\nexport default function Decryption() {\r\n\tconst [gifFile, setGifFile] = useState(null);\r\n\tconst [frames, setFrames] = useState([]);\r\n\tconst [error, setError] = useState(null);\r\n\tconst [password, setPassword] = useState(\"\");\r\n\r\n\tconst handleGIFChange = (e) => {\r\n\t\tconst file = e.target.files[0];\r\n\t\tif (!file) return;\r\n\t\tsetGifFile(file);\r\n\r\n\t\tToBits(file)\r\n\t\t\t.then(({ frames }) => setFrames(frames))\r\n\t\t\t.catch(err => setError(err.message));\r\n\t};\r\n\r\n\tconst handleExtractBinary = async () => {\r\n\t\tif (!frames.length) return;\r\n\t\tif (!password) {\r\n\t\t\tsetError(\"Password is required\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst allBits = [];\r\n\t\tfor (let frameIndex = 0; frameIndex < frames.length; frameIndex++) {\r\n\t\t\tconst patch = frames[frameIndex].patch;\r\n\t\t\tfor (let i = 0; i < patch.length; i += 4) {\r\n\t\t\t\tallBits.push(patch[i + 2] & 1); // LSB of blue channel\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Check header\r\n\t\tfor (let i = 0; i < HEADER_BITS.length; i++) {\r\n\t\t\tif (allBits[i] !== HEADER_BITS[i]) {\r\n\t\t\t\tsetError(\"Header not found in GIF.\");\r\n\t\t\t\tconsole.warn(\"Header read:\", allBits.slice(0, HEADER_BITS.length));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Extract metadata length\r\n\t\tconst metadataLengthBits = allBits.slice(HEADER_BITS.length, HEADER_BITS.length + 32);\r\n\t\tconst metadataLength = parseInt(metadataLengthBits.join(''), 2);\r\n\r\n\t\t// Extract metadata and payload\r\n\t\tconst metadataBits = allBits.slice(HEADER_BITS.length + 32, HEADER_BITS.length + 32 + metadataLength);\r\n\t\tconst payloadBits = allBits.slice(HEADER_BITS.length + 32 + metadataLength);\r\n\r\n\t\t// Convert metadata bits to string\r\n\t\tconst metadataText = bitArrayToString(metadataBits);\r\n\r\n\t\t// Now metadataText should be valid JSON if ToBinary stored Base64 IV/salt\r\n\t\tlet metadata;\r\n\t\ttry {\r\n\t\t\tmetadata = JSON.parse(metadataText);\r\n\t\t} catch (err) {\r\n\t\t\tconsole.error(\"Failed to parse metadata JSON:\", err);\r\n\t\t\tconsole.log(\"Metadata text:\", metadataText); // <-- inspect raw string\r\n\t\t\tsetError(\"Failed to parse metadata JSON.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconsole.log(\"Raw metadata text:\", metadataText);\r\n\r\n\t\t// Convert payload bits to Uint8Array ready for decryption\r\n\t\tconst encryptedBytes = bitArrayToUint8Array(payloadBits);\r\n\t\tconsole.log(\"Encrypted payload length:\", encryptedBytes.length);\r\n\r\n\t\t// Decode IV and salt for decryption\r\n\t\tconst ivArray = base64ToUint8Array(metadata.iv);\r\n\t\tconst saltArray = base64ToUint8Array(metadata.salt);\r\n\t\tconsole.log(\"IV:\", ivArray);\r\n\t\tconsole.log(\"Salt:\", saltArray);\r\n\r\n\r\n\t\tconst ivBuffer = ivArray.buffer;\r\n\t\tconst saltBuffer = saltArray.buffer;\r\n\t\tconsole.log(\"IV:\", ivBuffer);\r\n\t\tconsole.log(\"Salt:\", saltBuffer);\r\n\r\n\t\ttry {\r\n\t\t\tconst decryptedData = await decryptData(encryptedBytes, password, ivBuffer, saltBuffer);\r\n\t\t\tconsole.log(\"Decrypted data:\", decryptedData);\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error(\"Decryption failed:\", error);\r\n\t\t\tsetError(\"Decryption failed. Check password and try again.\");\r\n\t\t}\r\n\t};\r\n\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t<h2>Decrypt GIF Binary Data</h2>\r\n\t\t\t<input type=\"file\" accept=\"image/gif\" onChange={handleGIFChange} />\r\n\t\t\t{gifFile && <p>Uploaded GIF: {gifFile.name}</p>}\r\n\t\t\t<input type=\"password\" placeholder=\"Password\" value={password} onChange={(e) => setPassword(e.target.value)} />\r\n\t\t\t{frames.length > 0 && <button onClick={handleExtractBinary}>Extract Binary Data</button>}\r\n\t\t\t{error && <p className=\"error\">{error}</p>}\r\n\t\t</div>\r\n\t);\r\n}*/"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}