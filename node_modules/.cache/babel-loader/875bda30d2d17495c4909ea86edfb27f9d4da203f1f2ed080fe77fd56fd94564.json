{"ast":null,"code":"export function encodeGIF(gifFrames, binaryPayload, key = \"\") {\n  if (!(gifFrames !== null && gifFrames !== void 0 && gifFrames.length)) throw new Error(\"No GIF frames provided\");\n\n  // Optional encryption (on binary)\n  const payload = key ? xorBinary(binaryPayload, key) : binaryPayload;\n\n  // Add 32-bit length header\n  const lengthHeader = payload.length.toString(2).padStart(32, \"0\");\n  const fullPayload = lengthHeader + payload;\n  let bitIndex = 0;\n  for (const frame of gifFrames) {\n    const data = frame.patch;\n    for (let i = 0; i < data.length; i += 4) {\n      if (bitIndex >= fullPayload.length) return gifFrames;\n\n      // Blue channel = index + 2\n      data[i + 2] = data[i + 2] & ~1 | Number(fullPayload[bitIndex]);\n      bitIndex++;\n    }\n  }\n  if (bitIndex < fullPayload.length) {\n    console.warn(\"Payload truncated: GIF too small\");\n  }\n  return gifFrames;\n}\nexport function decodeGIF(gifFrames, key = \"\") {\n  if (!(gifFrames !== null && gifFrames !== void 0 && gifFrames.length)) throw new Error(\"No GIF frames provided\");\n  let bits = \"\";\n  for (const frame of gifFrames) {\n    const data = frame.patch;\n    for (let i = 0; i < data.length; i += 4) {\n      bits += (data[i + 2] & 1).toString();\n    }\n  }\n\n  // Read first 32 bits = payload length\n  const payloadLength = parseInt(bits.slice(0, 32), 2);\n  let payload = bits.slice(32, 32 + payloadLength);\n\n  // Optional decryption\n  if (key) {\n    payload = xorBinary(payload, key);\n  }\n  return payload;\n}\n\n/* =========================\n\t HELPERS\n========================= */\n\n/**\n * XOR encryption on binary string\n */\nfunction xorBinary(binary, key) {\n  const keyBinary = stringToBinary(key);\n  let result = \"\";\n  for (let i = 0; i < binary.length; i++) {\n    const bit = binary[i] ^ keyBinary[i % keyBinary.length];\n    result += bit;\n  }\n  return result;\n}\n\n/**\n * Convert string to binary\n */\nfunction stringToBinary(str) {\n  return Array.from(str).map(c => c.charCodeAt(0).toString(2).padStart(8, \"0\")).join(\"\");\n}","map":{"version":3,"names":["encodeGIF","gifFrames","binaryPayload","key","length","Error","payload","xorBinary","lengthHeader","toString","padStart","fullPayload","bitIndex","frame","data","patch","i","Number","console","warn","decodeGIF","bits","payloadLength","parseInt","slice","binary","keyBinary","stringToBinary","result","bit","str","Array","from","map","c","charCodeAt","join"],"sources":["/Users/melvinescobar/Steganography/src/components/Stego.js"],"sourcesContent":["\nexport function encodeGIF(gifFrames, binaryPayload, key = \"\") {\n\tif (!gifFrames?.length) throw new Error(\"No GIF frames provided\");\n\n\t// Optional encryption (on binary)\n\tconst payload = key\n\t\t? xorBinary(binaryPayload, key)\n\t\t: binaryPayload;\n\n\t// Add 32-bit length header\n\tconst lengthHeader = payload.length\n\t\t.toString(2)\n\t\t.padStart(32, \"0\");\n\n\tconst fullPayload = lengthHeader + payload;\n\n\tlet bitIndex = 0;\n\n\tfor (const frame of gifFrames) {\n\t\tconst data = frame.patch;\n\n\t\tfor (let i = 0; i < data.length; i += 4) {\n\t\t\tif (bitIndex >= fullPayload.length) return gifFrames;\n\n\t\t\t// Blue channel = index + 2\n\t\t\tdata[i + 2] = (data[i + 2] & ~1) | Number(fullPayload[bitIndex]);\n\t\t\tbitIndex++;\n\t\t}\n\t}\n\n\tif (bitIndex < fullPayload.length) {\n\t\tconsole.warn(\"Payload truncated: GIF too small\");\n\t}\n\n\treturn gifFrames;\n}\n\nexport function decodeGIF(gifFrames, key = \"\") {\n\tif (!gifFrames?.length) throw new Error(\"No GIF frames provided\");\n\n\tlet bits = \"\";\n\n\tfor (const frame of gifFrames) {\n\t\tconst data = frame.patch;\n\n\t\tfor (let i = 0; i < data.length; i += 4) {\n\t\t\tbits += (data[i + 2] & 1).toString();\n\t\t}\n\t}\n\n\t// Read first 32 bits = payload length\n\tconst payloadLength = parseInt(bits.slice(0, 32), 2);\n\tlet payload = bits.slice(32, 32 + payloadLength);\n\n\t// Optional decryption\n\tif (key) {\n\t\tpayload = xorBinary(payload, key);\n\t}\n\n\treturn payload;\n}\n\n/* =========================\n\t HELPERS\n========================= */\n\n/**\n * XOR encryption on binary string\n */\nfunction xorBinary(binary, key) {\n\tconst keyBinary = stringToBinary(key);\n\tlet result = \"\";\n\n\tfor (let i = 0; i < binary.length; i++) {\n\t\tconst bit =\n\t\t\tbinary[i] ^ keyBinary[i % keyBinary.length];\n\t\tresult += bit;\n\t}\n\n\treturn result;\n}\n\n/**\n * Convert string to binary\n */\nfunction stringToBinary(str) {\n\treturn Array.from(str)\n\t\t.map(c => c.charCodeAt(0).toString(2).padStart(8, \"0\"))\n\t\t.join(\"\");\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}