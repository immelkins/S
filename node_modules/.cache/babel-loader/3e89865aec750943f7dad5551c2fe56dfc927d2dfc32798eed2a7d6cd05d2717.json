{"ast":null,"code":"/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\nvar JpegImage = function jpegImage() {\n  \"use strict\";\n\n  var dctZigZag = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);\n  var dctCos1 = 4017; // cos(pi/16)\n  var dctSin1 = 799; // sin(pi/16)\n  var dctCos3 = 3406; // cos(3*pi/16)\n  var dctSin3 = 2276; // sin(3*pi/16)\n  var dctCos6 = 1567; // cos(6*pi/16)\n  var dctSin6 = 3784; // sin(6*pi/16)\n  var dctSqrt2 = 5793; // sqrt(2)\n  var dctSqrt1d2 = 2896; // sqrt(2) / 2\n\n  function constructor() {}\n  function buildHuffmanTable(codeLengths, values) {\n    var k = 0,\n      code = [],\n      i,\n      j,\n      length = 16;\n    while (length > 0 && !codeLengths[length - 1]) length--;\n    code.push({\n      children: [],\n      index: 0\n    });\n    var p = code[0],\n      q;\n    for (i = 0; i < length; i++) {\n      for (j = 0; j < codeLengths[i]; j++) {\n        p = code.pop();\n        p.children[p.index] = values[k];\n        while (p.index > 0) {\n          if (code.length === 0) throw new Error('Could not recreate Huffman Table');\n          p = code.pop();\n        }\n        p.index++;\n        code.push(p);\n        while (code.length <= i) {\n          code.push(q = {\n            children: [],\n            index: 0\n          });\n          p.children[p.index] = q.children;\n          p = q;\n        }\n        k++;\n      }\n      if (i + 1 < length) {\n        // p here points to last code\n        code.push(q = {\n          children: [],\n          index: 0\n        });\n        p.children[p.index] = q.children;\n        p = q;\n      }\n    }\n    return code[0].children;\n  }\n  function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {\n    var precision = frame.precision;\n    var samplesPerLine = frame.samplesPerLine;\n    var scanLines = frame.scanLines;\n    var mcusPerLine = frame.mcusPerLine;\n    var progressive = frame.progressive;\n    var maxH = frame.maxH,\n      maxV = frame.maxV;\n    var startOffset = offset,\n      bitsData = 0,\n      bitsCount = 0;\n    function readBit() {\n      if (bitsCount > 0) {\n        bitsCount--;\n        return bitsData >> bitsCount & 1;\n      }\n      bitsData = data[offset++];\n      if (bitsData == 0xFF) {\n        var nextByte = data[offset++];\n        if (nextByte) {\n          throw new Error(\"unexpected marker: \" + (bitsData << 8 | nextByte).toString(16));\n        }\n        // unstuff 0\n      }\n      bitsCount = 7;\n      return bitsData >>> 7;\n    }\n    function decodeHuffman(tree) {\n      var node = tree,\n        bit;\n      while ((bit = readBit()) !== null) {\n        node = node[bit];\n        if (typeof node === 'number') return node;\n        if (typeof node !== 'object') throw new Error(\"invalid huffman sequence\");\n      }\n      return null;\n    }\n    function receive(length) {\n      var n = 0;\n      while (length > 0) {\n        var bit = readBit();\n        if (bit === null) return;\n        n = n << 1 | bit;\n        length--;\n      }\n      return n;\n    }\n    function receiveAndExtend(length) {\n      var n = receive(length);\n      if (n >= 1 << length - 1) return n;\n      return n + (-1 << length) + 1;\n    }\n    function decodeBaseline(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : receiveAndExtend(t);\n      zz[0] = component.pred += diff;\n      var k = 1;\n      while (k < 64) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15,\n          r = rs >> 4;\n        if (s === 0) {\n          if (r < 15) break;\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n    function decodeDCFirst(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;\n      zz[0] = component.pred += diff;\n    }\n    function decodeDCSuccessive(component, zz) {\n      zz[0] |= readBit() << successive;\n    }\n    var eobrun = 0;\n    function decodeACFirst(component, zz) {\n      if (eobrun > 0) {\n        eobrun--;\n        return;\n      }\n      var k = spectralStart,\n        e = spectralEnd;\n      while (k <= e) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15,\n          r = rs >> 4;\n        if (s === 0) {\n          if (r < 15) {\n            eobrun = receive(r) + (1 << r) - 1;\n            break;\n          }\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n    var successiveACState = 0,\n      successiveACNextValue;\n    function decodeACSuccessive(component, zz) {\n      var k = spectralStart,\n        e = spectralEnd,\n        r = 0;\n      while (k <= e) {\n        var z = dctZigZag[k];\n        var direction = zz[z] < 0 ? -1 : 1;\n        switch (successiveACState) {\n          case 0:\n            // initial state\n            var rs = decodeHuffman(component.huffmanTableAC);\n            var s = rs & 15,\n              r = rs >> 4;\n            if (s === 0) {\n              if (r < 15) {\n                eobrun = receive(r) + (1 << r);\n                successiveACState = 4;\n              } else {\n                r = 16;\n                successiveACState = 1;\n              }\n            } else {\n              if (s !== 1) throw new Error(\"invalid ACn encoding\");\n              successiveACNextValue = receiveAndExtend(s);\n              successiveACState = r ? 2 : 3;\n            }\n            continue;\n          case 1: // skipping r zero items\n          case 2:\n            if (zz[z]) zz[z] += (readBit() << successive) * direction;else {\n              r--;\n              if (r === 0) successiveACState = successiveACState == 2 ? 3 : 0;\n            }\n            break;\n          case 3:\n            // set value for a zero item\n            if (zz[z]) zz[z] += (readBit() << successive) * direction;else {\n              zz[z] = successiveACNextValue << successive;\n              successiveACState = 0;\n            }\n            break;\n          case 4:\n            // eob\n            if (zz[z]) zz[z] += (readBit() << successive) * direction;\n            break;\n        }\n        k++;\n      }\n      if (successiveACState === 4) {\n        eobrun--;\n        if (eobrun === 0) successiveACState = 0;\n      }\n    }\n    function decodeMcu(component, decode, mcu, row, col) {\n      var mcuRow = mcu / mcusPerLine | 0;\n      var mcuCol = mcu % mcusPerLine;\n      var blockRow = mcuRow * component.v + row;\n      var blockCol = mcuCol * component.h + col;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n    function decodeBlock(component, decode, mcu) {\n      var blockRow = mcu / component.blocksPerLine | 0;\n      var blockCol = mcu % component.blocksPerLine;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n    var componentsLength = components.length;\n    var component, i, j, k, n;\n    var decodeFn;\n    if (progressive) {\n      if (spectralStart === 0) decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;else decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    } else {\n      decodeFn = decodeBaseline;\n    }\n    var mcu = 0,\n      marker;\n    var mcuExpected;\n    if (componentsLength == 1) {\n      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n    } else {\n      mcuExpected = mcusPerLine * frame.mcusPerColumn;\n    }\n    if (!resetInterval) resetInterval = mcuExpected;\n    var h, v;\n    while (mcu < mcuExpected) {\n      // reset interval stuff\n      for (i = 0; i < componentsLength; i++) components[i].pred = 0;\n      eobrun = 0;\n      if (componentsLength == 1) {\n        component = components[0];\n        for (n = 0; n < resetInterval; n++) {\n          decodeBlock(component, decodeFn, mcu);\n          mcu++;\n        }\n      } else {\n        for (n = 0; n < resetInterval; n++) {\n          for (i = 0; i < componentsLength; i++) {\n            component = components[i];\n            h = component.h;\n            v = component.v;\n            for (j = 0; j < v; j++) {\n              for (k = 0; k < h; k++) {\n                decodeMcu(component, decodeFn, mcu, j, k);\n              }\n            }\n          }\n          mcu++;\n\n          // If we've reached our expected MCU's, stop decoding\n          if (mcu === mcuExpected) break;\n        }\n      }\n\n      // find marker\n      bitsCount = 0;\n      marker = data[offset] << 8 | data[offset + 1];\n      if (marker < 0xFF00) {\n        throw new Error(\"marker was not found\");\n      }\n      if (marker >= 0xFFD0 && marker <= 0xFFD7) {\n        // RSTx\n        offset += 2;\n      } else break;\n    }\n    return offset - startOffset;\n  }\n  function buildComponentData(frame, component) {\n    var lines = [];\n    var blocksPerLine = component.blocksPerLine;\n    var blocksPerColumn = component.blocksPerColumn;\n    var samplesPerLine = blocksPerLine << 3;\n    var R = new Int32Array(64),\n      r = new Uint8Array(64);\n\n    // A port of poppler's IDCT method which in turn is taken from:\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n    //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n    //   988-991.\n    function quantizeAndInverse(zz, dataOut, dataIn) {\n      var qt = component.quantizationTable;\n      var v0, v1, v2, v3, v4, v5, v6, v7, t;\n      var p = dataIn;\n      var i;\n\n      // dequant\n      for (i = 0; i < 64; i++) p[i] = zz[i] * qt[i];\n\n      // inverse DCT on rows\n      for (i = 0; i < 8; ++i) {\n        var row = 8 * i;\n\n        // check for all-zero AC coefficients\n        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {\n          t = dctSqrt2 * p[0 + row] + 512 >> 10;\n          p[0 + row] = t;\n          p[1 + row] = t;\n          p[2 + row] = t;\n          p[3 + row] = t;\n          p[4 + row] = t;\n          p[5 + row] = t;\n          p[6 + row] = t;\n          p[7 + row] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = dctSqrt2 * p[0 + row] + 128 >> 8;\n        v1 = dctSqrt2 * p[4 + row] + 128 >> 8;\n        v2 = p[2 + row];\n        v3 = p[6 + row];\n        v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;\n        v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;\n        v5 = p[3 + row] << 4;\n        v6 = p[5 + row] << 4;\n\n        // stage 3\n        t = v0 - v1 + 1 >> 1;\n        v0 = v0 + v1 + 1 >> 1;\n        v1 = t;\n        t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;\n        v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;\n        v3 = t;\n        t = v4 - v6 + 1 >> 1;\n        v4 = v4 + v6 + 1 >> 1;\n        v6 = t;\n        t = v7 + v5 + 1 >> 1;\n        v5 = v7 - v5 + 1 >> 1;\n        v7 = t;\n\n        // stage 2\n        t = v0 - v3 + 1 >> 1;\n        v0 = v0 + v3 + 1 >> 1;\n        v3 = t;\n        t = v1 - v2 + 1 >> 1;\n        v1 = v1 + v2 + 1 >> 1;\n        v2 = t;\n        t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\n        v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\n        v7 = t;\n        t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\n        v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0 + row] = v0 + v7;\n        p[7 + row] = v0 - v7;\n        p[1 + row] = v1 + v6;\n        p[6 + row] = v1 - v6;\n        p[2 + row] = v2 + v5;\n        p[5 + row] = v2 - v5;\n        p[3 + row] = v3 + v4;\n        p[4 + row] = v3 - v4;\n      }\n\n      // inverse DCT on columns\n      for (i = 0; i < 8; ++i) {\n        var col = i;\n\n        // check for all-zero AC coefficients\n        if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {\n          t = dctSqrt2 * dataIn[i + 0] + 8192 >> 14;\n          p[0 * 8 + col] = t;\n          p[1 * 8 + col] = t;\n          p[2 * 8 + col] = t;\n          p[3 * 8 + col] = t;\n          p[4 * 8 + col] = t;\n          p[5 * 8 + col] = t;\n          p[6 * 8 + col] = t;\n          p[7 * 8 + col] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;\n        v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;\n        v2 = p[2 * 8 + col];\n        v3 = p[6 * 8 + col];\n        v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;\n        v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;\n        v5 = p[3 * 8 + col];\n        v6 = p[5 * 8 + col];\n\n        // stage 3\n        t = v0 - v1 + 1 >> 1;\n        v0 = v0 + v1 + 1 >> 1;\n        v1 = t;\n        t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;\n        v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;\n        v3 = t;\n        t = v4 - v6 + 1 >> 1;\n        v4 = v4 + v6 + 1 >> 1;\n        v6 = t;\n        t = v7 + v5 + 1 >> 1;\n        v5 = v7 - v5 + 1 >> 1;\n        v7 = t;\n\n        // stage 2\n        t = v0 - v3 + 1 >> 1;\n        v0 = v0 + v3 + 1 >> 1;\n        v3 = t;\n        t = v1 - v2 + 1 >> 1;\n        v1 = v1 + v2 + 1 >> 1;\n        v2 = t;\n        t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\n        v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\n        v7 = t;\n        t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\n        v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0 * 8 + col] = v0 + v7;\n        p[7 * 8 + col] = v0 - v7;\n        p[1 * 8 + col] = v1 + v6;\n        p[6 * 8 + col] = v1 - v6;\n        p[2 * 8 + col] = v2 + v5;\n        p[5 * 8 + col] = v2 - v5;\n        p[3 * 8 + col] = v3 + v4;\n        p[4 * 8 + col] = v3 - v4;\n      }\n\n      // convert to 8-bit integers\n      for (i = 0; i < 64; ++i) {\n        var sample = 128 + (p[i] + 8 >> 4);\n        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;\n      }\n    }\n    var i, j;\n    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n      var scanLine = blockRow << 3;\n      for (i = 0; i < 8; i++) lines.push(new Uint8Array(samplesPerLine));\n      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n        var offset = 0,\n          sample = blockCol << 3;\n        for (j = 0; j < 8; j++) {\n          var line = lines[scanLine + j];\n          for (i = 0; i < 8; i++) line[sample + i] = r[offset++];\n        }\n      }\n    }\n    return lines;\n  }\n  function clampTo8bit(a) {\n    return a < 0 ? 0 : a > 255 ? 255 : a;\n  }\n  constructor.prototype = {\n    load: function load(path) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", path, true);\n      xhr.responseType = \"arraybuffer\";\n      xhr.onload = function () {\n        // TODO catch parse error\n        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n        this.parse(data);\n        if (this.onload) this.onload();\n      }.bind(this);\n      xhr.send(null);\n    },\n    parse: function parse(data) {\n      var offset = 0,\n        length = data.length;\n      function readUint16() {\n        var value = data[offset] << 8 | data[offset + 1];\n        offset += 2;\n        return value;\n      }\n      function readDataBlock() {\n        var length = readUint16();\n        var array = data.subarray(offset, offset + length - 2);\n        offset += array.length;\n        return array;\n      }\n      function prepareComponents(frame) {\n        var maxH = 0,\n          maxV = 0;\n        var component, componentId;\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            if (maxH < component.h) maxH = component.h;\n            if (maxV < component.v) maxV = component.v;\n          }\n        }\n        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);\n            var blocksPerLineForMcu = mcusPerLine * component.h;\n            var blocksPerColumnForMcu = mcusPerColumn * component.v;\n            var blocks = [];\n            for (var i = 0; i < blocksPerColumnForMcu; i++) {\n              var row = [];\n              for (var j = 0; j < blocksPerLineForMcu; j++) row.push(new Int32Array(64));\n              blocks.push(row);\n            }\n            component.blocksPerLine = blocksPerLine;\n            component.blocksPerColumn = blocksPerColumn;\n            component.blocks = blocks;\n          }\n        }\n        frame.maxH = maxH;\n        frame.maxV = maxV;\n        frame.mcusPerLine = mcusPerLine;\n        frame.mcusPerColumn = mcusPerColumn;\n      }\n      var jfif = null;\n      var adobe = null;\n      var pixels = null;\n      var frame, resetInterval;\n      var quantizationTables = [],\n        frames = [];\n      var huffmanTablesAC = [],\n        huffmanTablesDC = [];\n      var fileMarker = readUint16();\n      if (fileMarker != 0xFFD8) {\n        // SOI (Start of Image)\n        throw new Error(\"SOI not found\");\n      }\n      fileMarker = readUint16();\n      while (fileMarker != 0xFFD9) {\n        // EOI (End of image)\n        var i, j, l;\n        switch (fileMarker) {\n          case 0xFF00:\n            break;\n          case 0xFFE0: // APP0 (Application Specific)\n          case 0xFFE1: // APP1\n          case 0xFFE2: // APP2\n          case 0xFFE3: // APP3\n          case 0xFFE4: // APP4\n          case 0xFFE5: // APP5\n          case 0xFFE6: // APP6\n          case 0xFFE7: // APP7\n          case 0xFFE8: // APP8\n          case 0xFFE9: // APP9\n          case 0xFFEA: // APP10\n          case 0xFFEB: // APP11\n          case 0xFFEC: // APP12\n          case 0xFFED: // APP13\n          case 0xFFEE: // APP14\n          case 0xFFEF: // APP15\n          case 0xFFFE:\n            // COM (Comment)\n            var appData = readDataBlock();\n            if (fileMarker === 0xFFE0) {\n              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 && appData[3] === 0x46 && appData[4] === 0) {\n                // 'JFIF\\x00'\n                jfif = {\n                  version: {\n                    major: appData[5],\n                    minor: appData[6]\n                  },\n                  densityUnits: appData[7],\n                  xDensity: appData[8] << 8 | appData[9],\n                  yDensity: appData[10] << 8 | appData[11],\n                  thumbWidth: appData[12],\n                  thumbHeight: appData[13],\n                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                };\n              }\n            }\n            // TODO APP1 - Exif\n            if (fileMarker === 0xFFEE) {\n              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) {\n                // 'Adobe\\x00'\n                adobe = {\n                  version: appData[6],\n                  flags0: appData[7] << 8 | appData[8],\n                  flags1: appData[9] << 8 | appData[10],\n                  transformCode: appData[11]\n                };\n              }\n            }\n            break;\n          case 0xFFDB:\n            // DQT (Define Quantization Tables)\n            var quantizationTablesLength = readUint16();\n            var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n            while (offset < quantizationTablesEnd) {\n              var quantizationTableSpec = data[offset++];\n              var tableData = new Int32Array(64);\n              if (quantizationTableSpec >> 4 === 0) {\n                // 8 bit values\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = data[offset++];\n                }\n              } else if (quantizationTableSpec >> 4 === 1) {\n                //16 bit\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = readUint16();\n                }\n              } else throw new Error(\"DQT: invalid table spec\");\n              quantizationTables[quantizationTableSpec & 15] = tableData;\n            }\n            break;\n          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n          case 0xFFC2:\n            // SOF2 (Start of Frame, Progressive DCT)\n            readUint16(); // skip data length\n            frame = {};\n            frame.extended = fileMarker === 0xFFC1;\n            frame.progressive = fileMarker === 0xFFC2;\n            frame.precision = data[offset++];\n            frame.scanLines = readUint16();\n            frame.samplesPerLine = readUint16();\n            frame.components = {};\n            frame.componentsOrder = [];\n            var componentsCount = data[offset++],\n              componentId;\n            var maxH = 0,\n              maxV = 0;\n            for (i = 0; i < componentsCount; i++) {\n              componentId = data[offset];\n              var h = data[offset + 1] >> 4;\n              var v = data[offset + 1] & 15;\n              var qId = data[offset + 2];\n              frame.componentsOrder.push(componentId);\n              frame.components[componentId] = {\n                h: h,\n                v: v,\n                quantizationIdx: qId\n              };\n              offset += 3;\n            }\n            prepareComponents(frame);\n            frames.push(frame);\n            break;\n          case 0xFFC4:\n            // DHT (Define Huffman Tables)\n            var huffmanLength = readUint16();\n            for (i = 2; i < huffmanLength;) {\n              var huffmanTableSpec = data[offset++];\n              var codeLengths = new Uint8Array(16);\n              var codeLengthSum = 0;\n              for (j = 0; j < 16; j++, offset++) codeLengthSum += codeLengths[j] = data[offset];\n              var huffmanValues = new Uint8Array(codeLengthSum);\n              for (j = 0; j < codeLengthSum; j++, offset++) huffmanValues[j] = data[offset];\n              i += 17 + codeLengthSum;\n              (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\n            }\n            break;\n          case 0xFFDD:\n            // DRI (Define Restart Interval)\n            readUint16(); // skip data length\n            resetInterval = readUint16();\n            break;\n          case 0xFFDA:\n            // SOS (Start of Scan)\n            var scanLength = readUint16();\n            var selectorsCount = data[offset++];\n            var components = [],\n              component;\n            for (i = 0; i < selectorsCount; i++) {\n              component = frame.components[data[offset++]];\n              var tableSpec = data[offset++];\n              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n              components.push(component);\n            }\n            var spectralStart = data[offset++];\n            var spectralEnd = data[offset++];\n            var successiveApproximation = data[offset++];\n            var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);\n            offset += processed;\n            break;\n          case 0xFFFF:\n            // Fill bytes\n            if (data[offset] !== 0xFF) {\n              // Avoid skipping a valid marker.\n              offset--;\n            }\n            break;\n          default:\n            if (data[offset - 3] == 0xFF && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n              // could be incorrect encoding -- last 0xFF byte of the previous\n              // block was eaten by the encoder\n              offset -= 3;\n              break;\n            }\n            throw new Error(\"unknown JPEG marker \" + fileMarker.toString(16));\n        }\n        fileMarker = readUint16();\n      }\n      if (frames.length != 1) throw new Error(\"only single frame JPEGs supported\");\n\n      // set each frame's components quantization table\n      for (var i = 0; i < frames.length; i++) {\n        var cp = frames[i].components;\n        for (var j in cp) {\n          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];\n          delete cp[j].quantizationIdx;\n        }\n      }\n      this.width = frame.samplesPerLine;\n      this.height = frame.scanLines;\n      this.jfif = jfif;\n      this.adobe = adobe;\n      this.components = [];\n      for (var i = 0; i < frame.componentsOrder.length; i++) {\n        var component = frame.components[frame.componentsOrder[i]];\n        this.components.push({\n          lines: buildComponentData(frame, component),\n          scaleX: component.h / frame.maxH,\n          scaleY: component.v / frame.maxV\n        });\n      }\n    },\n    getData: function getData(width, height) {\n      var scaleX = this.width / width,\n        scaleY = this.height / height;\n      var component1, component2, component3, component4;\n      var component1Line, component2Line, component3Line, component4Line;\n      var x, y;\n      var offset = 0;\n      var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n      var colorTransform;\n      var dataLength = width * height * this.components.length;\n      var data = new Uint8Array(dataLength);\n      switch (this.components.length) {\n        case 1:\n          component1 = this.components[0];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | y * component1.scaleY * scaleY];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | x * component1.scaleX * scaleX];\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 2:\n          // PDF might compress two component data in custom colorspace\n          component1 = this.components[0];\n          component2 = this.components[1];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | y * component1.scaleY * scaleY];\n            component2Line = component2.lines[0 | y * component2.scaleY * scaleY];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | x * component1.scaleX * scaleX];\n              data[offset++] = Y;\n              Y = component2Line[0 | x * component2.scaleX * scaleX];\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 3:\n          // The default transform for three components is true\n          colorTransform = true;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode) colorTransform = true;else if (typeof this.colorTransform !== 'undefined') colorTransform = !!this.colorTransform;\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | y * component1.scaleY * scaleY];\n            component2Line = component2.lines[0 | y * component2.scaleY * scaleY];\n            component3Line = component3.lines[0 | y * component3.scaleY * scaleY];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                R = component1Line[0 | x * component1.scaleX * scaleX];\n                G = component2Line[0 | x * component2.scaleX * scaleX];\n                B = component3Line[0 | x * component3.scaleX * scaleX];\n              } else {\n                Y = component1Line[0 | x * component1.scaleX * scaleX];\n                Cb = component2Line[0 | x * component2.scaleX * scaleX];\n                Cr = component3Line[0 | x * component3.scaleX * scaleX];\n                R = clampTo8bit(Y + 1.402 * (Cr - 128));\n                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                B = clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n              data[offset++] = R;\n              data[offset++] = G;\n              data[offset++] = B;\n            }\n          }\n          break;\n        case 4:\n          if (!this.adobe) throw new Error('Unsupported color mode (4 components)');\n          // The default transform for four components is false\n          colorTransform = false;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode) colorTransform = true;else if (typeof this.colorTransform !== 'undefined') colorTransform = !!this.colorTransform;\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          component4 = this.components[3];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | y * component1.scaleY * scaleY];\n            component2Line = component2.lines[0 | y * component2.scaleY * scaleY];\n            component3Line = component3.lines[0 | y * component3.scaleY * scaleY];\n            component4Line = component4.lines[0 | y * component4.scaleY * scaleY];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                C = component1Line[0 | x * component1.scaleX * scaleX];\n                M = component2Line[0 | x * component2.scaleX * scaleX];\n                Ye = component3Line[0 | x * component3.scaleX * scaleX];\n                K = component4Line[0 | x * component4.scaleX * scaleX];\n              } else {\n                Y = component1Line[0 | x * component1.scaleX * scaleX];\n                Cb = component2Line[0 | x * component2.scaleX * scaleX];\n                Cr = component3Line[0 | x * component3.scaleX * scaleX];\n                K = component4Line[0 | x * component4.scaleX * scaleX];\n                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));\n                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n              data[offset++] = 255 - C;\n              data[offset++] = 255 - M;\n              data[offset++] = 255 - Ye;\n              data[offset++] = 255 - K;\n            }\n          }\n          break;\n        default:\n          throw new Error('Unsupported color mode');\n      }\n      return data;\n    },\n    copyToImageData: function copyToImageData(imageData, formatAsRGBA) {\n      var width = imageData.width,\n        height = imageData.height;\n      var imageDataArray = imageData.data;\n      var data = this.getData(width, height);\n      var i = 0,\n        j = 0,\n        x,\n        y;\n      var Y, K, C, M, R, G, B;\n      switch (this.components.length) {\n        case 1:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              Y = data[i++];\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        case 3:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              R = data[i++];\n              G = data[i++];\n              B = data[i++];\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        case 4:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              C = data[i++];\n              M = data[i++];\n              Y = data[i++];\n              K = data[i++];\n              R = 255 - clampTo8bit(C * (1 - K / 255) + K);\n              G = 255 - clampTo8bit(M * (1 - K / 255) + K);\n              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        default:\n          throw new Error('Unsupported color mode');\n      }\n    }\n  };\n  return constructor;\n}();\nmodule.exports = decode;\nfunction decode(jpegData, opts) {\n  var defaultOpts = {\n    useTArray: false,\n    // \"undefined\" means \"Choose whether to transform colors based on the imageâ€™s color model.\"\n    colorTransform: undefined,\n    formatAsRGBA: true\n  };\n  if (opts) {\n    if (typeof opts === 'object') {\n      opts = {\n        useTArray: typeof opts.useTArray === 'undefined' ? defaultOpts.useTArray : opts.useTArray,\n        colorTransform: typeof opts.colorTransform === 'undefined' ? defaultOpts.colorTransform : opts.colorTransform,\n        formatAsRGBA: typeof opts.formatAsRGBA === 'undefined' ? defaultOpts.formatAsRGBA : opts.formatAsRGBA\n      };\n    } else {\n      // backwards compatiblity, before 0.3.5, we only had the useTArray param\n      opts = defaultOpts;\n      opts.useTArray = true;\n    }\n  } else {\n    opts = defaultOpts;\n  }\n  var arr = new Uint8Array(jpegData);\n  var decoder = new JpegImage();\n  decoder.parse(arr);\n  decoder.colorTransform = opts.colorTransform;\n  var channels = opts.formatAsRGBA ? 4 : 3;\n  var bytesNeeded = decoder.width * decoder.height * channels;\n  try {\n    var image = {\n      width: decoder.width,\n      height: decoder.height,\n      data: opts.useTArray ? new Uint8Array(bytesNeeded) : new Buffer(bytesNeeded)\n    };\n  } catch (err) {\n    if (err instanceof RangeError) {\n      throw new Error(\"Could not allocate enough memory for the image. \" + \"Required: \" + bytesNeeded);\n    } else {\n      throw err;\n    }\n  }\n  decoder.copyToImageData(image, opts.formatAsRGBA);\n  return image;\n}","map":{"version":3,"names":["JpegImage","jpegImage","dctZigZag","Int32Array","dctCos1","dctSin1","dctCos3","dctSin3","dctCos6","dctSin6","dctSqrt2","dctSqrt1d2","constructor","buildHuffmanTable","codeLengths","values","k","code","i","j","length","push","children","index","p","q","pop","Error","decodeScan","data","offset","frame","components","resetInterval","spectralStart","spectralEnd","successivePrev","successive","precision","samplesPerLine","scanLines","mcusPerLine","progressive","maxH","maxV","startOffset","bitsData","bitsCount","readBit","nextByte","toString","decodeHuffman","tree","node","bit","receive","n","receiveAndExtend","decodeBaseline","component","zz","t","huffmanTableDC","diff","pred","rs","huffmanTableAC","s","r","z","decodeDCFirst","decodeDCSuccessive","eobrun","decodeACFirst","e","successiveACState","successiveACNextValue","decodeACSuccessive","direction","decodeMcu","decode","mcu","row","col","mcuRow","mcuCol","blockRow","v","blockCol","h","blocks","decodeBlock","blocksPerLine","componentsLength","decodeFn","marker","mcuExpected","blocksPerColumn","mcusPerColumn","buildComponentData","lines","R","Uint8Array","quantizeAndInverse","dataOut","dataIn","qt","quantizationTable","v0","v1","v2","v3","v4","v5","v6","v7","sample","scanLine","line","clampTo8bit","a","prototype","load","path","xhr","XMLHttpRequest","open","responseType","onload","response","mozResponseArrayBuffer","parse","bind","send","readUint16","value","readDataBlock","array","subarray","prepareComponents","componentId","hasOwnProperty","Math","ceil","blocksPerLineForMcu","blocksPerColumnForMcu","jfif","adobe","pixels","quantizationTables","frames","huffmanTablesAC","huffmanTablesDC","fileMarker","l","appData","version","major","minor","densityUnits","xDensity","yDensity","thumbWidth","thumbHeight","thumbData","flags0","flags1","transformCode","quantizationTablesLength","quantizationTablesEnd","quantizationTableSpec","tableData","extended","componentsOrder","componentsCount","qId","quantizationIdx","huffmanLength","huffmanTableSpec","codeLengthSum","huffmanValues","scanLength","selectorsCount","tableSpec","successiveApproximation","processed","cp","width","height","scaleX","scaleY","getData","component1","component2","component3","component4","component1Line","component2Line","component3Line","component4Line","x","y","Y","Cb","Cr","K","C","M","Ye","G","B","colorTransform","dataLength","copyToImageData","imageData","formatAsRGBA","imageDataArray","module","exports","jpegData","opts","defaultOpts","useTArray","undefined","arr","decoder","channels","bytesNeeded","image","Buffer","err","RangeError"],"sources":["/Users/melvinescobar/Steganography/node_modules/jpeg-js/lib/decoder.js"],"sourcesContent":["/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\nvar JpegImage = (function jpegImage() {\n  \"use strict\";\n  var dctZigZag = new Int32Array([\n     0,\n     1,  8,\n    16,  9,  2,\n     3, 10, 17, 24,\n    32, 25, 18, 11, 4,\n     5, 12, 19, 26, 33, 40,\n    48, 41, 34, 27, 20, 13,  6,\n     7, 14, 21, 28, 35, 42, 49, 56,\n    57, 50, 43, 36, 29, 22, 15,\n    23, 30, 37, 44, 51, 58,\n    59, 52, 45, 38, 31,\n    39, 46, 53, 60,\n    61, 54, 47,\n    55, 62,\n    63\n  ]);\n\n  var dctCos1  =  4017   // cos(pi/16)\n  var dctSin1  =   799   // sin(pi/16)\n  var dctCos3  =  3406   // cos(3*pi/16)\n  var dctSin3  =  2276   // sin(3*pi/16)\n  var dctCos6  =  1567   // cos(6*pi/16)\n  var dctSin6  =  3784   // sin(6*pi/16)\n  var dctSqrt2 =  5793   // sqrt(2)\n  var dctSqrt1d2 = 2896  // sqrt(2) / 2\n\n  function constructor() {\n  }\n\n  function buildHuffmanTable(codeLengths, values) {\n    var k = 0, code = [], i, j, length = 16;\n    while (length > 0 && !codeLengths[length - 1])\n      length--;\n    code.push({children: [], index: 0});\n    var p = code[0], q;\n    for (i = 0; i < length; i++) {\n      for (j = 0; j < codeLengths[i]; j++) {\n        p = code.pop();\n        p.children[p.index] = values[k];\n        while (p.index > 0) {\n          if (code.length === 0)\n            throw new Error('Could not recreate Huffman Table');\n          p = code.pop();\n        }\n        p.index++;\n        code.push(p);\n        while (code.length <= i) {\n          code.push(q = {children: [], index: 0});\n          p.children[p.index] = q.children;\n          p = q;\n        }\n        k++;\n      }\n      if (i + 1 < length) {\n        // p here points to last code\n        code.push(q = {children: [], index: 0});\n        p.children[p.index] = q.children;\n        p = q;\n      }\n    }\n    return code[0].children;\n  }\n\n  function decodeScan(data, offset,\n                      frame, components, resetInterval,\n                      spectralStart, spectralEnd,\n                      successivePrev, successive) {\n    var precision = frame.precision;\n    var samplesPerLine = frame.samplesPerLine;\n    var scanLines = frame.scanLines;\n    var mcusPerLine = frame.mcusPerLine;\n    var progressive = frame.progressive;\n    var maxH = frame.maxH, maxV = frame.maxV;\n\n    var startOffset = offset, bitsData = 0, bitsCount = 0;\n    function readBit() {\n      if (bitsCount > 0) {\n        bitsCount--;\n        return (bitsData >> bitsCount) & 1;\n      }\n      bitsData = data[offset++];\n      if (bitsData == 0xFF) {\n        var nextByte = data[offset++];\n        if (nextByte) {\n          throw new Error(\"unexpected marker: \" + ((bitsData << 8) | nextByte).toString(16));\n        }\n        // unstuff 0\n      }\n      bitsCount = 7;\n      return bitsData >>> 7;\n    }\n    function decodeHuffman(tree) {\n      var node = tree, bit;\n      while ((bit = readBit()) !== null) {\n        node = node[bit];\n        if (typeof node === 'number')\n          return node;\n        if (typeof node !== 'object')\n          throw new Error(\"invalid huffman sequence\");\n      }\n      return null;\n    }\n    function receive(length) {\n      var n = 0;\n      while (length > 0) {\n        var bit = readBit();\n        if (bit === null) return;\n        n = (n << 1) | bit;\n        length--;\n      }\n      return n;\n    }\n    function receiveAndExtend(length) {\n      var n = receive(length);\n      if (n >= 1 << (length - 1))\n        return n;\n      return n + (-1 << length) + 1;\n    }\n    function decodeBaseline(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : receiveAndExtend(t);\n      zz[0]= (component.pred += diff);\n      var k = 1;\n      while (k < 64) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15, r = rs >> 4;\n        if (s === 0) {\n          if (r < 15)\n            break;\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n    function decodeDCFirst(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n      zz[0] = (component.pred += diff);\n    }\n    function decodeDCSuccessive(component, zz) {\n      zz[0] |= readBit() << successive;\n    }\n    var eobrun = 0;\n    function decodeACFirst(component, zz) {\n      if (eobrun > 0) {\n        eobrun--;\n        return;\n      }\n      var k = spectralStart, e = spectralEnd;\n      while (k <= e) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15, r = rs >> 4;\n        if (s === 0) {\n          if (r < 15) {\n            eobrun = receive(r) + (1 << r) - 1;\n            break;\n          }\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n    var successiveACState = 0, successiveACNextValue;\n    function decodeACSuccessive(component, zz) {\n      var k = spectralStart, e = spectralEnd, r = 0;\n      while (k <= e) {\n        var z = dctZigZag[k];\n        var direction = zz[z] < 0 ? -1 : 1;\n        switch (successiveACState) {\n        case 0: // initial state\n          var rs = decodeHuffman(component.huffmanTableAC);\n          var s = rs & 15, r = rs >> 4;\n          if (s === 0) {\n            if (r < 15) {\n              eobrun = receive(r) + (1 << r);\n              successiveACState = 4;\n            } else {\n              r = 16;\n              successiveACState = 1;\n            }\n          } else {\n            if (s !== 1)\n              throw new Error(\"invalid ACn encoding\");\n            successiveACNextValue = receiveAndExtend(s);\n            successiveACState = r ? 2 : 3;\n          }\n          continue;\n        case 1: // skipping r zero items\n        case 2:\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          else {\n            r--;\n            if (r === 0)\n              successiveACState = successiveACState == 2 ? 3 : 0;\n          }\n          break;\n        case 3: // set value for a zero item\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          else {\n            zz[z] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4: // eob\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          break;\n        }\n        k++;\n      }\n      if (successiveACState === 4) {\n        eobrun--;\n        if (eobrun === 0)\n          successiveACState = 0;\n      }\n    }\n    function decodeMcu(component, decode, mcu, row, col) {\n      var mcuRow = (mcu / mcusPerLine) | 0;\n      var mcuCol = mcu % mcusPerLine;\n      var blockRow = mcuRow * component.v + row;\n      var blockCol = mcuCol * component.h + col;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n    function decodeBlock(component, decode, mcu) {\n      var blockRow = (mcu / component.blocksPerLine) | 0;\n      var blockCol = mcu % component.blocksPerLine;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n\n    var componentsLength = components.length;\n    var component, i, j, k, n;\n    var decodeFn;\n    if (progressive) {\n      if (spectralStart === 0)\n        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n      else\n        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    } else {\n      decodeFn = decodeBaseline;\n    }\n\n    var mcu = 0, marker;\n    var mcuExpected;\n    if (componentsLength == 1) {\n      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n    } else {\n      mcuExpected = mcusPerLine * frame.mcusPerColumn;\n    }\n    if (!resetInterval) resetInterval = mcuExpected;\n\n    var h, v;\n    while (mcu < mcuExpected) {\n      // reset interval stuff\n      for (i = 0; i < componentsLength; i++)\n        components[i].pred = 0;\n      eobrun = 0;\n\n      if (componentsLength == 1) {\n        component = components[0];\n        for (n = 0; n < resetInterval; n++) {\n          decodeBlock(component, decodeFn, mcu);\n          mcu++;\n        }\n      } else {\n        for (n = 0; n < resetInterval; n++) {\n          for (i = 0; i < componentsLength; i++) {\n            component = components[i];\n            h = component.h;\n            v = component.v;\n            for (j = 0; j < v; j++) {\n              for (k = 0; k < h; k++) {\n                decodeMcu(component, decodeFn, mcu, j, k);\n              }\n            }\n          }\n          mcu++;\n\n          // If we've reached our expected MCU's, stop decoding\n          if (mcu === mcuExpected) break;\n        }\n      }\n\n      // find marker\n      bitsCount = 0;\n      marker = (data[offset] << 8) | data[offset + 1];\n      if (marker < 0xFF00) {\n        throw new Error(\"marker was not found\");\n      }\n\n      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n        offset += 2;\n      }\n      else\n        break;\n    }\n\n    return offset - startOffset;\n  }\n\n  function buildComponentData(frame, component) {\n    var lines = [];\n    var blocksPerLine = component.blocksPerLine;\n    var blocksPerColumn = component.blocksPerColumn;\n    var samplesPerLine = blocksPerLine << 3;\n    var R = new Int32Array(64), r = new Uint8Array(64);\n\n    // A port of poppler's IDCT method which in turn is taken from:\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n    //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n    //   988-991.\n    function quantizeAndInverse(zz, dataOut, dataIn) {\n      var qt = component.quantizationTable;\n      var v0, v1, v2, v3, v4, v5, v6, v7, t;\n      var p = dataIn;\n      var i;\n\n      // dequant\n      for (i = 0; i < 64; i++)\n        p[i] = zz[i] * qt[i];\n\n      // inverse DCT on rows\n      for (i = 0; i < 8; ++i) {\n        var row = 8 * i;\n\n        // check for all-zero AC coefficients\n        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&\n            p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&\n            p[7 + row] == 0) {\n          t = (dctSqrt2 * p[0 + row] + 512) >> 10;\n          p[0 + row] = t;\n          p[1 + row] = t;\n          p[2 + row] = t;\n          p[3 + row] = t;\n          p[4 + row] = t;\n          p[5 + row] = t;\n          p[6 + row] = t;\n          p[7 + row] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;\n        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;\n        v2 = p[2 + row];\n        v3 = p[6 + row];\n        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;\n        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;\n        v5 = p[3 + row] << 4;\n        v6 = p[5 + row] << 4;\n\n        // stage 3\n        t = (v0 - v1+ 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n\n        // stage 2\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0 + row] = v0 + v7;\n        p[7 + row] = v0 - v7;\n        p[1 + row] = v1 + v6;\n        p[6 + row] = v1 - v6;\n        p[2 + row] = v2 + v5;\n        p[5 + row] = v2 - v5;\n        p[3 + row] = v3 + v4;\n        p[4 + row] = v3 - v4;\n      }\n\n      // inverse DCT on columns\n      for (i = 0; i < 8; ++i) {\n        var col = i;\n\n        // check for all-zero AC coefficients\n        if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&\n            p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&\n            p[7*8 + col] == 0) {\n          t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;\n          p[0*8 + col] = t;\n          p[1*8 + col] = t;\n          p[2*8 + col] = t;\n          p[3*8 + col] = t;\n          p[4*8 + col] = t;\n          p[5*8 + col] = t;\n          p[6*8 + col] = t;\n          p[7*8 + col] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;\n        v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;\n        v2 = p[2*8 + col];\n        v3 = p[6*8 + col];\n        v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;\n        v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;\n        v5 = p[3*8 + col];\n        v6 = p[5*8 + col];\n\n        // stage 3\n        t = (v0 - v1 + 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n\n        // stage 2\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0*8 + col] = v0 + v7;\n        p[7*8 + col] = v0 - v7;\n        p[1*8 + col] = v1 + v6;\n        p[6*8 + col] = v1 - v6;\n        p[2*8 + col] = v2 + v5;\n        p[5*8 + col] = v2 - v5;\n        p[3*8 + col] = v3 + v4;\n        p[4*8 + col] = v3 - v4;\n      }\n\n      // convert to 8-bit integers\n      for (i = 0; i < 64; ++i) {\n        var sample = 128 + ((p[i] + 8) >> 4);\n        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;\n      }\n    }\n\n    var i, j;\n    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n      var scanLine = blockRow << 3;\n      for (i = 0; i < 8; i++)\n        lines.push(new Uint8Array(samplesPerLine));\n      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n\n        var offset = 0, sample = blockCol << 3;\n        for (j = 0; j < 8; j++) {\n          var line = lines[scanLine + j];\n          for (i = 0; i < 8; i++)\n            line[sample + i] = r[offset++];\n        }\n      }\n    }\n    return lines;\n  }\n\n  function clampTo8bit(a) {\n    return a < 0 ? 0 : a > 255 ? 255 : a;\n  }\n\n  constructor.prototype = {\n    load: function load(path) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", path, true);\n      xhr.responseType = \"arraybuffer\";\n      xhr.onload = (function() {\n        // TODO catch parse error\n        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n        this.parse(data);\n        if (this.onload)\n          this.onload();\n      }).bind(this);\n      xhr.send(null);\n    },\n    parse: function parse(data) {\n      var offset = 0, length = data.length;\n      function readUint16() {\n        var value = (data[offset] << 8) | data[offset + 1];\n        offset += 2;\n        return value;\n      }\n      function readDataBlock() {\n        var length = readUint16();\n        var array = data.subarray(offset, offset + length - 2);\n        offset += array.length;\n        return array;\n      }\n      function prepareComponents(frame) {\n        var maxH = 0, maxV = 0;\n        var component, componentId;\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            if (maxH < component.h) maxH = component.h;\n            if (maxV < component.v) maxV = component.v;\n          }\n        }\n        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);\n            var blocksPerLineForMcu = mcusPerLine * component.h;\n            var blocksPerColumnForMcu = mcusPerColumn * component.v;\n            var blocks = [];\n            for (var i = 0; i < blocksPerColumnForMcu; i++) {\n              var row = [];\n              for (var j = 0; j < blocksPerLineForMcu; j++)\n                row.push(new Int32Array(64));\n              blocks.push(row);\n            }\n            component.blocksPerLine = blocksPerLine;\n            component.blocksPerColumn = blocksPerColumn;\n            component.blocks = blocks;\n          }\n        }\n        frame.maxH = maxH;\n        frame.maxV = maxV;\n        frame.mcusPerLine = mcusPerLine;\n        frame.mcusPerColumn = mcusPerColumn;\n      }\n      var jfif = null;\n      var adobe = null;\n      var pixels = null;\n      var frame, resetInterval;\n      var quantizationTables = [], frames = [];\n      var huffmanTablesAC = [], huffmanTablesDC = [];\n      var fileMarker = readUint16();\n      if (fileMarker != 0xFFD8) { // SOI (Start of Image)\n        throw new Error(\"SOI not found\");\n      }\n\n      fileMarker = readUint16();\n      while (fileMarker != 0xFFD9) { // EOI (End of image)\n        var i, j, l;\n        switch(fileMarker) {\n          case 0xFF00: break;\n          case 0xFFE0: // APP0 (Application Specific)\n          case 0xFFE1: // APP1\n          case 0xFFE2: // APP2\n          case 0xFFE3: // APP3\n          case 0xFFE4: // APP4\n          case 0xFFE5: // APP5\n          case 0xFFE6: // APP6\n          case 0xFFE7: // APP7\n          case 0xFFE8: // APP8\n          case 0xFFE9: // APP9\n          case 0xFFEA: // APP10\n          case 0xFFEB: // APP11\n          case 0xFFEC: // APP12\n          case 0xFFED: // APP13\n          case 0xFFEE: // APP14\n          case 0xFFEF: // APP15\n          case 0xFFFE: // COM (Comment)\n            var appData = readDataBlock();\n\n            if (fileMarker === 0xFFE0) {\n              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&\n                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n                jfif = {\n                  version: { major: appData[5], minor: appData[6] },\n                  densityUnits: appData[7],\n                  xDensity: (appData[8] << 8) | appData[9],\n                  yDensity: (appData[10] << 8) | appData[11],\n                  thumbWidth: appData[12],\n                  thumbHeight: appData[13],\n                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                };\n              }\n            }\n            // TODO APP1 - Exif\n            if (fileMarker === 0xFFEE) {\n              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&\n                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n                adobe = {\n                  version: appData[6],\n                  flags0: (appData[7] << 8) | appData[8],\n                  flags1: (appData[9] << 8) | appData[10],\n                  transformCode: appData[11]\n                };\n              }\n            }\n            break;\n\n          case 0xFFDB: // DQT (Define Quantization Tables)\n            var quantizationTablesLength = readUint16();\n            var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n            while (offset < quantizationTablesEnd) {\n              var quantizationTableSpec = data[offset++];\n              var tableData = new Int32Array(64);\n              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = data[offset++];\n                }\n              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = readUint16();\n                }\n              } else\n                throw new Error(\"DQT: invalid table spec\");\n              quantizationTables[quantizationTableSpec & 15] = tableData;\n            }\n            break;\n\n          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)\n            readUint16(); // skip data length\n            frame = {};\n            frame.extended = (fileMarker === 0xFFC1);\n            frame.progressive = (fileMarker === 0xFFC2);\n            frame.precision = data[offset++];\n            frame.scanLines = readUint16();\n            frame.samplesPerLine = readUint16();\n            frame.components = {};\n            frame.componentsOrder = [];\n            var componentsCount = data[offset++], componentId;\n            var maxH = 0, maxV = 0;\n            for (i = 0; i < componentsCount; i++) {\n              componentId = data[offset];\n              var h = data[offset + 1] >> 4;\n              var v = data[offset + 1] & 15;\n              var qId = data[offset + 2];\n              frame.componentsOrder.push(componentId);\n              frame.components[componentId] = {\n                h: h,\n                v: v,\n                quantizationIdx: qId\n              };\n              offset += 3;\n            }\n            prepareComponents(frame);\n            frames.push(frame);\n            break;\n\n          case 0xFFC4: // DHT (Define Huffman Tables)\n            var huffmanLength = readUint16();\n            for (i = 2; i < huffmanLength;) {\n              var huffmanTableSpec = data[offset++];\n              var codeLengths = new Uint8Array(16);\n              var codeLengthSum = 0;\n              for (j = 0; j < 16; j++, offset++)\n                codeLengthSum += (codeLengths[j] = data[offset]);\n              var huffmanValues = new Uint8Array(codeLengthSum);\n              for (j = 0; j < codeLengthSum; j++, offset++)\n                huffmanValues[j] = data[offset];\n              i += 17 + codeLengthSum;\n\n              ((huffmanTableSpec >> 4) === 0 ?\n                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =\n                buildHuffmanTable(codeLengths, huffmanValues);\n            }\n            break;\n\n          case 0xFFDD: // DRI (Define Restart Interval)\n            readUint16(); // skip data length\n            resetInterval = readUint16();\n            break;\n\n          case 0xFFDA: // SOS (Start of Scan)\n            var scanLength = readUint16();\n            var selectorsCount = data[offset++];\n            var components = [], component;\n            for (i = 0; i < selectorsCount; i++) {\n              component = frame.components[data[offset++]];\n              var tableSpec = data[offset++];\n              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n              components.push(component);\n            }\n            var spectralStart = data[offset++];\n            var spectralEnd = data[offset++];\n            var successiveApproximation = data[offset++];\n            var processed = decodeScan(data, offset,\n              frame, components, resetInterval,\n              spectralStart, spectralEnd,\n              successiveApproximation >> 4, successiveApproximation & 15);\n            offset += processed;\n            break;\n\n          case 0xFFFF: // Fill bytes\n            if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\n              offset--;\n            }\n            break;\n\n          default:\n            if (data[offset - 3] == 0xFF &&\n                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n              // could be incorrect encoding -- last 0xFF byte of the previous\n              // block was eaten by the encoder\n              offset -= 3;\n              break;\n            }\n            throw new Error(\"unknown JPEG marker \" + fileMarker.toString(16));\n        }\n        fileMarker = readUint16();\n      }\n      if (frames.length != 1)\n        throw new Error(\"only single frame JPEGs supported\");\n\n      // set each frame's components quantization table\n      for (var i = 0; i < frames.length; i++) {\n        var cp = frames[i].components;\n        for (var j in cp) {\n          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];\n          delete cp[j].quantizationIdx;\n        }\n      }\n\n      this.width = frame.samplesPerLine;\n      this.height = frame.scanLines;\n      this.jfif = jfif;\n      this.adobe = adobe;\n      this.components = [];\n      for (var i = 0; i < frame.componentsOrder.length; i++) {\n        var component = frame.components[frame.componentsOrder[i]];\n        this.components.push({\n          lines: buildComponentData(frame, component),\n          scaleX: component.h / frame.maxH,\n          scaleY: component.v / frame.maxV\n        });\n      }\n    },\n    getData: function getData(width, height) {\n      var scaleX = this.width / width, scaleY = this.height / height;\n\n      var component1, component2, component3, component4;\n      var component1Line, component2Line, component3Line, component4Line;\n      var x, y;\n      var offset = 0;\n      var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n      var colorTransform;\n      var dataLength = width * height * this.components.length;\n      var data = new Uint8Array(dataLength);\n      switch (this.components.length) {\n        case 1:\n          component1 = this.components[0];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 2:\n          // PDF might compress two component data in custom colorspace\n          component1 = this.components[0];\n          component2 = this.components[1];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n              data[offset++] = Y;\n              Y = component2Line[0 | (x * component2.scaleX * scaleX)];\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 3:\n          // The default transform for three components is true\n          colorTransform = true;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode)\n            colorTransform = true;\n          else if (typeof this.colorTransform !== 'undefined')\n            colorTransform = !!this.colorTransform;\n\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                R = component1Line[0 | (x * component1.scaleX * scaleX)];\n                G = component2Line[0 | (x * component2.scaleX * scaleX)];\n                B = component3Line[0 | (x * component3.scaleX * scaleX)];\n              } else {\n                Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];\n\n                R = clampTo8bit(Y + 1.402 * (Cr - 128));\n                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                B = clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n\n              data[offset++] = R;\n              data[offset++] = G;\n              data[offset++] = B;\n            }\n          }\n          break;\n        case 4:\n          if (!this.adobe)\n            throw new Error('Unsupported color mode (4 components)');\n          // The default transform for four components is false\n          colorTransform = false;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode)\n            colorTransform = true;\n          else if (typeof this.colorTransform !== 'undefined')\n            colorTransform = !!this.colorTransform;\n\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          component4 = this.components[3];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];\n            component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                C = component1Line[0 | (x * component1.scaleX * scaleX)];\n                M = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Ye = component3Line[0 | (x * component3.scaleX * scaleX)];\n                K = component4Line[0 | (x * component4.scaleX * scaleX)];\n              } else {\n                Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];\n                K = component4Line[0 | (x * component4.scaleX * scaleX)];\n\n                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));\n                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n              data[offset++] = 255-C;\n              data[offset++] = 255-M;\n              data[offset++] = 255-Ye;\n              data[offset++] = 255-K;\n            }\n          }\n          break;\n        default:\n          throw new Error('Unsupported color mode');\n      }\n      return data;\n    },\n    copyToImageData: function copyToImageData(imageData, formatAsRGBA) {\n      var width = imageData.width, height = imageData.height;\n      var imageDataArray = imageData.data;\n      var data = this.getData(width, height);\n      var i = 0, j = 0, x, y;\n      var Y, K, C, M, R, G, B;\n      switch (this.components.length) {\n        case 1:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              Y = data[i++];\n\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        case 3:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              R = data[i++];\n              G = data[i++];\n              B = data[i++];\n\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        case 4:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              C = data[i++];\n              M = data[i++];\n              Y = data[i++];\n              K = data[i++];\n\n              R = 255 - clampTo8bit(C * (1 - K / 255) + K);\n              G = 255 - clampTo8bit(M * (1 - K / 255) + K);\n              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);\n\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        default:\n          throw new Error('Unsupported color mode');\n      }\n    }\n  };\n\n  return constructor;\n})();\nmodule.exports = decode;\n\nfunction decode(jpegData, opts) {\n  var defaultOpts = {\n    useTArray: false,\n    // \"undefined\" means \"Choose whether to transform colors based on the imageâ€™s color model.\"\n    colorTransform: undefined,\n    formatAsRGBA: true\n  };\n  if (opts) {\n    if (typeof opts === 'object') {\n      opts = {\n        useTArray: (typeof opts.useTArray === 'undefined' ?\n                    defaultOpts.useTArray : opts.useTArray),\n        colorTransform: (typeof opts.colorTransform === 'undefined' ?\n                         defaultOpts.colorTransform : opts.colorTransform),\n        formatAsRGBA: (typeof opts.formatAsRGBA === 'undefined' ?\n                         defaultOpts.formatAsRGBA : opts.formatAsRGBA)\n      };\n    } else {\n      // backwards compatiblity, before 0.3.5, we only had the useTArray param\n      opts = defaultOpts;\n      opts.useTArray = true;\n    }\n  } else {\n    opts = defaultOpts;\n  }\n\n  var arr = new Uint8Array(jpegData);\n  var decoder = new JpegImage();\n  decoder.parse(arr);\n  decoder.colorTransform = opts.colorTransform;\n\n  var channels = (opts.formatAsRGBA) ? 4 : 3;\n  var bytesNeeded = decoder.width * decoder.height * channels;\n  try {\n    var image = {\n      width: decoder.width,\n      height: decoder.height,\n      data: opts.useTArray ?\n        new Uint8Array(bytesNeeded) :\n        new Buffer(bytesNeeded)\n    };\n  } catch (err){\n    if (err instanceof RangeError){\n      throw new Error(\"Could not allocate enough memory for the image. \" +\n                      \"Required: \" + bytesNeeded);\n    } else {\n      throw err;\n    }\n  }\n\n  decoder.copyToImageData(image, opts.formatAsRGBA);\n\n  return image;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}