{"ast":null,"code":"// stego.js\n\nimport { parseGIF, decompressFrames } from \"gifuct-js\";\nimport ToBinary from \"./ToBinBits\";\nexport async function encodeFromUpload(gifFile, payloadFile, key = \"\") {\n  if (!gifFile) throw new Error(\"No GIF file provided\");\n  if (!payloadFile) throw new Error(\"No payload file provided\");\n\n  // Convert payload file → binary\n  const binaryPayload = await ToBinary(p2ayloadFile);\n\n  // Decode GIF → frames\n  const gifBuffer = await gifFile.arrayBuffer();\n  const gif = parseGIF(gifBuffer);\n  const frames = decompressFrames(gif, true);\n\n  // Encode binary into frames\n  encodeGIF(frames, binaryPayload, key);\n  return frames;\n}\nexport async function decodeFromUpload(gifFile, key = \"\") {\n  if (!gifFile) throw new Error(\"No GIF file provided\");\n  const gifBuffer = await gifFile.arrayBuffer();\n  const gif = parseGIF(gifBuffer);\n  const frames = decompressFrames(gif, true);\n  return decodeGIF(frames, key);\n}\n\n/* =========================\n   CORE STEGO FUNCTIONS\n========================= */\n\nfunction encodeGIF(gifFrames, binaryPayload, key = \"\") {\n  if (!(gifFrames !== null && gifFrames !== void 0 && gifFrames.length)) throw new Error(\"No GIF frames provided\");\n\n  // Optional XOR encryption\n  const payload = key ? xorBinary(binaryPayload, key) : binaryPayload;\n\n  // 32-bit length header\n  const lengthHeader = payload.length.toString(2).padStart(32, \"0\");\n  const fullPayload = lengthHeader + payload;\n  let bitIndex = 0;\n  for (const frame of gifFrames) {\n    const data = frame.patch;\n    for (let i = 0; i < data.length; i += 4) {\n      if (bitIndex >= fullPayload.length) return gifFrames;\n\n      // Blue channel LSB\n      data[i + 2] = data[i + 2] & ~1 | Number(fullPayload[bitIndex]);\n      bitIndex++;\n    }\n  }\n  if (bitIndex < fullPayload.length) {\n    console.warn(\"Payload truncated: GIF too small\");\n  }\n  return gifFrames;\n}\nfunction decodeGIF(gifFrames, key = \"\") {\n  if (!(gifFrames !== null && gifFrames !== void 0 && gifFrames.length)) throw new Error(\"No GIF frames provided\");\n  let bits = \"\";\n  for (const frame of gifFrames) {\n    const data = frame.patch;\n    for (let i = 0; i < data.length; i += 4) {\n      bits += (data[i + 2] & 1).toString();\n    }\n  }\n\n  // First 32 bits = payload length\n  const payloadLength = parseInt(bits.slice(0, 32), 2);\n  let payload = bits.slice(32, 32 + payloadLength);\n  if (key) {\n    payload = xorBinary(payload, key);\n  }\n  return payload;\n}\n\n/* =========================\n   HELPERS\n========================= */\n\nfunction xorBinary(binary, key) {\n  const keyBinary = stringToBinary(key);\n  let result = \"\";\n  for (let i = 0; i < binary.length; i++) {\n    result += binary[i] ^ keyBinary[i % keyBinary.length];\n  }\n  return result;\n}\nfunction stringToBinary(str) {\n  return Array.from(str).map(c => c.charCodeAt(0).toString(2).padStart(8, \"0\")).join(\"\");\n}","map":{"version":3,"names":["parseGIF","decompressFrames","ToBinary","encodeFromUpload","gifFile","payloadFile","key","Error","binaryPayload","p2ayloadFile","gifBuffer","arrayBuffer","gif","frames","encodeGIF","decodeFromUpload","decodeGIF","gifFrames","length","payload","xorBinary","lengthHeader","toString","padStart","fullPayload","bitIndex","frame","data","patch","i","Number","console","warn","bits","payloadLength","parseInt","slice","binary","keyBinary","stringToBinary","result","str","Array","from","map","c","charCodeAt","join"],"sources":["/Users/melvinescobar/Steganography/src/components/Stego.js"],"sourcesContent":["// stego.js\n\nimport { parseGIF, decompressFrames } from \"gifuct-js\";\nimport ToBinary from \"./ToBinBits\";\n\nexport async function encodeFromUpload(gifFile, payloadFile, key = \"\") {\n  if (!gifFile) throw new Error(\"No GIF file provided\");\n  if (!payloadFile) throw new Error(\"No payload file provided\");\n\n  // Convert payload file → binary\n  const binaryPayload = await ToBinary(p2ayloadFile);\n\n  // Decode GIF → frames\n  const gifBuffer = await gifFile.arrayBuffer();\n  const gif = parseGIF(gifBuffer);\n  const frames = decompressFrames(gif, true);\n\n  // Encode binary into frames\n  encodeGIF(frames, binaryPayload, key);\n\n  return frames;\n}\n\nexport async function decodeFromUpload(gifFile, key = \"\") {\n  if (!gifFile) throw new Error(\"No GIF file provided\");\n\n  const gifBuffer = await gifFile.arrayBuffer();\n  const gif = parseGIF(gifBuffer);\n  const frames = decompressFrames(gif, true);\n\n  return decodeGIF(frames, key);\n}\n\n/* =========================\n   CORE STEGO FUNCTIONS\n========================= */\n\nfunction encodeGIF(gifFrames, binaryPayload, key = \"\") {\n  if (!gifFrames?.length) throw new Error(\"No GIF frames provided\");\n\n  // Optional XOR encryption\n  const payload = key ? xorBinary(binaryPayload, key) : binaryPayload;\n\n  // 32-bit length header\n  const lengthHeader = payload.length\n    .toString(2)\n    .padStart(32, \"0\");\n\n  const fullPayload = lengthHeader + payload;\n\n  let bitIndex = 0;\n\n  for (const frame of gifFrames) {\n    const data = frame.patch;\n\n    for (let i = 0; i < data.length; i += 4) {\n      if (bitIndex >= fullPayload.length) return gifFrames;\n\n      // Blue channel LSB\n      data[i + 2] = (data[i + 2] & ~1) | Number(fullPayload[bitIndex]);\n      bitIndex++;\n    }\n  }\n\n  if (bitIndex < fullPayload.length) {\n    console.warn(\"Payload truncated: GIF too small\");\n  }\n\n  return gifFrames;\n}\n\nfunction decodeGIF(gifFrames, key = \"\") {\n  if (!gifFrames?.length) throw new Error(\"No GIF frames provided\");\n\n  let bits = \"\";\n\n  for (const frame of gifFrames) {\n    const data = frame.patch;\n\n    for (let i = 0; i < data.length; i += 4) {\n      bits += (data[i + 2] & 1).toString();\n    }\n  }\n\n  // First 32 bits = payload length\n  const payloadLength = parseInt(bits.slice(0, 32), 2);\n  let payload = bits.slice(32, 32 + payloadLength);\n\n  if (key) {\n    payload = xorBinary(payload, key);\n  }\n\n  return payload;\n}\n\n/* =========================\n   HELPERS\n========================= */\n\nfunction xorBinary(binary, key) {\n  const keyBinary = stringToBinary(key);\n  let result = \"\";\n\n  for (let i = 0; i < binary.length; i++) {\n    result += binary[i] ^ keyBinary[i % keyBinary.length];\n  }\n\n  return result;\n}\n\nfunction stringToBinary(str) {\n  return Array.from(str)\n    .map(c => c.charCodeAt(0).toString(2).padStart(8, \"0\"))\n    .join(\"\");\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}