{"ast":null,"code":"// FromBinaryMetadata.js\n\n/**\r\n * Reads metadata from the binary string with a 32-bit length header\r\n * and prints it to the console\r\n * @param {string} metabits - Binary string containing metadata with 32-bit length header\r\n */\nexport default function printMetadataFromBinary(metabits) {\n  if (!metabits || metabits.length < 32) {\n    console.error(\"Metadata binary is too short\");\n    return;\n  }\n\n  // 1️⃣ Extract 32-bit length header\n  const lengthBits = metabits.slice(0, 32);\n  const metadataLength = parseInt(lengthBits, 2);\n\n  // 2️⃣ Extract metadata bits\n  const metadataBits = metabits.slice(32, 32 + metadataLength);\n  if (metadataBits.length !== metadataLength) {\n    console.error(\"Metadata length mismatch\");\n    return;\n  }\n\n  // 3️⃣ Convert binary to string\n  let metadataStr = '';\n  for (let i = 0; i < metadataBits.length; i += 8) {\n    const byte = metadataBits.slice(i, i + 8);\n    metadataStr += String.fromCharCode(parseInt(byte, 2));\n  }\n\n  // 4️⃣ Parse JSON and print\n  try {\n    const metadata = JSON.parse(metadataStr);\n    console.log(\"Decoded Metadata:\", metadata);\n  } catch (err) {\n    console.error(\"Failed to parse metadata JSON:\", err.message);\n  }\n}","map":{"version":3,"names":["printMetadataFromBinary","metabits","length","console","error","lengthBits","slice","metadataLength","parseInt","metadataBits","metadataStr","i","byte","String","fromCharCode","metadata","JSON","parse","log","err","message"],"sources":["C:/Users/mesco/OneDrive/Documents/GitHub/S/src/components/ToExtract.js"],"sourcesContent":["// FromBinaryMetadata.js\r\n\r\n/**\r\n * Reads metadata from the binary string with a 32-bit length header\r\n * and prints it to the console\r\n * @param {string} metabits - Binary string containing metadata with 32-bit length header\r\n */\r\nexport default function printMetadataFromBinary(metabits) {\r\n  if (!metabits || metabits.length < 32) {\r\n    console.error(\"Metadata binary is too short\");\r\n    return;\r\n  }\r\n\r\n  // 1️⃣ Extract 32-bit length header\r\n  const lengthBits = metabits.slice(0, 32);\r\n  const metadataLength = parseInt(lengthBits, 2);\r\n\r\n  // 2️⃣ Extract metadata bits\r\n  const metadataBits = metabits.slice(32, 32 + metadataLength);\r\n  if (metadataBits.length !== metadataLength) {\r\n    console.error(\"Metadata length mismatch\");\r\n    return;\r\n  }\r\n\r\n  // 3️⃣ Convert binary to string\r\n  let metadataStr = '';\r\n  for (let i = 0; i < metadataBits.length; i += 8) {\r\n    const byte = metadataBits.slice(i, i + 8);\r\n    metadataStr += String.fromCharCode(parseInt(byte, 2));\r\n  }\r\n\r\n  // 4️⃣ Parse JSON and print\r\n  try {\r\n    const metadata = JSON.parse(metadataStr);\r\n    console.log(\"Decoded Metadata:\", metadata);\r\n  } catch (err) {\r\n    console.error(\"Failed to parse metadata JSON:\", err.message);\r\n  }\r\n}\r\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,uBAAuBA,CAACC,QAAQ,EAAE;EACxD,IAAI,CAACA,QAAQ,IAAIA,QAAQ,CAACC,MAAM,GAAG,EAAE,EAAE;IACrCC,OAAO,CAACC,KAAK,CAAC,8BAA8B,CAAC;IAC7C;EACF;;EAEA;EACA,MAAMC,UAAU,GAAGJ,QAAQ,CAACK,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EACxC,MAAMC,cAAc,GAAGC,QAAQ,CAACH,UAAU,EAAE,CAAC,CAAC;;EAE9C;EACA,MAAMI,YAAY,GAAGR,QAAQ,CAACK,KAAK,CAAC,EAAE,EAAE,EAAE,GAAGC,cAAc,CAAC;EAC5D,IAAIE,YAAY,CAACP,MAAM,KAAKK,cAAc,EAAE;IAC1CJ,OAAO,CAACC,KAAK,CAAC,0BAA0B,CAAC;IACzC;EACF;;EAEA;EACA,IAAIM,WAAW,GAAG,EAAE;EACpB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,YAAY,CAACP,MAAM,EAAES,CAAC,IAAI,CAAC,EAAE;IAC/C,MAAMC,IAAI,GAAGH,YAAY,CAACH,KAAK,CAACK,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;IACzCD,WAAW,IAAIG,MAAM,CAACC,YAAY,CAACN,QAAQ,CAACI,IAAI,EAAE,CAAC,CAAC,CAAC;EACvD;;EAEA;EACA,IAAI;IACF,MAAMG,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACP,WAAW,CAAC;IACxCP,OAAO,CAACe,GAAG,CAAC,mBAAmB,EAAEH,QAAQ,CAAC;EAC5C,CAAC,CAAC,OAAOI,GAAG,EAAE;IACZhB,OAAO,CAACC,KAAK,CAAC,gCAAgC,EAAEe,GAAG,CAACC,OAAO,CAAC;EAC9D;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}