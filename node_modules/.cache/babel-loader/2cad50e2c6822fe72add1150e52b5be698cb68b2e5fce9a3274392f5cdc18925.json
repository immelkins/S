{"ast":null,"code":"// ToBinary.js\n/*import { encryptData } from \"./ToBlackBox\";\r\n\r\nexport default async function ToBinary(file, password) {\r\n  if (!file) throw new Error(\"No file provided\");\r\n  if (!password || password.trim() === \"\") throw new Error(\"Password is required for encryption\");\r\n\r\n  const arrayBuffer = await file.arrayBuffer();\r\n  const bytes = new Uint8Array(arrayBuffer);\r\n\r\n  // Convert file content to binary\r\n  let binary = '';\r\n  for (let i = 0; i < bytes.length; i++) {\r\n    binary += bytes[i].toString(2).padStart(8, '0');\r\n  }\r\n\r\n  const { encryptedData, iv, salt } = await encryptData(binary, password);\r\n  const encryptedBinary = Array.from(encryptedData)\r\n    .map(byte => byte.toString(2).padStart(8, '0'))\r\n    .join('');\r\n\r\n  // Metadata object\r\n  const metadata = {\r\n    iv,\r\n    salt,\r\n    originalLength: binary.length,\r\n    fileName: file.name,\r\n    fileType: file.type,\r\n  };\r\n\r\n  // Convert metadata to binary\r\n  const metadataStr = JSON.stringify(metadata);\r\n  let metadataBinary = '';\r\n  for (let i = 0; i < metadataStr.length; i++) {\r\n    metadataBinary += metadataStr.charCodeAt(i).toString(2).padStart(8, '0');\r\n  }\r\n\r\n  // Add 32-bit length header at the start\r\n  const metadataLength = metadataBinary.length; // in bits\r\n  const lengthBinary = metadataLength.toString(2).padStart(32, '0');\r\n  metadataBinary = lengthBinary + metadataBinary;\r\n\r\n  return {\r\n    bits: encryptedBinary,\r\n    metabits: metadataBinary,\r\n  };\r\n}\r\n*/","map":{"version":3,"names":[],"sources":["C:/Users/mesco/OneDrive/Documents/GitHub/S/src/components/ToBinary.js"],"sourcesContent":["// ToBinary.js\r\n/*import { encryptData } from \"./ToBlackBox\";\r\n\r\nexport default async function ToBinary(file, password) {\r\n  if (!file) throw new Error(\"No file provided\");\r\n  if (!password || password.trim() === \"\") throw new Error(\"Password is required for encryption\");\r\n\r\n  const arrayBuffer = await file.arrayBuffer();\r\n  const bytes = new Uint8Array(arrayBuffer);\r\n\r\n  // Convert file content to binary\r\n  let binary = '';\r\n  for (let i = 0; i < bytes.length; i++) {\r\n    binary += bytes[i].toString(2).padStart(8, '0');\r\n  }\r\n\r\n  const { encryptedData, iv, salt } = await encryptData(binary, password);\r\n  const encryptedBinary = Array.from(encryptedData)\r\n    .map(byte => byte.toString(2).padStart(8, '0'))\r\n    .join('');\r\n\r\n  // Metadata object\r\n  const metadata = {\r\n    iv,\r\n    salt,\r\n    originalLength: binary.length,\r\n    fileName: file.name,\r\n    fileType: file.type,\r\n  };\r\n\r\n  // Convert metadata to binary\r\n  const metadataStr = JSON.stringify(metadata);\r\n  let metadataBinary = '';\r\n  for (let i = 0; i < metadataStr.length; i++) {\r\n    metadataBinary += metadataStr.charCodeAt(i).toString(2).padStart(8, '0');\r\n  }\r\n\r\n  // Add 32-bit length header at the start\r\n  const metadataLength = metadataBinary.length; // in bits\r\n  const lengthBinary = metadataLength.toString(2).padStart(32, '0');\r\n  metadataBinary = lengthBinary + metadataBinary;\r\n\r\n  return {\r\n    bits: encryptedBinary,\r\n    metabits: metadataBinary,\r\n  };\r\n}\r\n*/"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}