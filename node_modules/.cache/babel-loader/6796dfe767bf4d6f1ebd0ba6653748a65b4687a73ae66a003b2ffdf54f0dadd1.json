{"ast":null,"code":"// ToBinary.js \nimport { encryptData } from \"./ToBlackBox\";\nfunction uint8ArrayToBitArray(bytes) {\n  const bits = [];\n  for (const byte of bytes) {\n    for (let i = 7; i >= 0; i--) {\n      bits.push(byte >> i & 1);\n    }\n  }\n  return bits;\n}\nfunction stringToBitArray(str) {\n  const bits = [];\n  for (let i = 0; i < str.length; i++) {\n    const byte = str.charCodeAt(i);\n    for (let j = 7; j >= 0; j--) {\n      bits.push(byte >> j & 1);\n    }\n  }\n  return bits;\n}\nfunction numberTo32BitArray(num) {\n  const bits = [];\n  for (let i = 31; i >= 0; i--) {\n    bits.push(num >> i & 1);\n  }\n  return bits;\n} // Helper: Convert Uint8Array to Base64 string function uint8ArrayToBase64(uint8Array) { return btoa(String.fromCharCode(...uint8Array)); } export default async function ToBinary(file, password) { if (!file) throw new Error(\"No file provided\"); if (!password || password.trim() === \"\") throw new Error(\"Password is required for encryption\"); const arrayBuffer = await file.arrayBuffer(); const bytes = new Uint8Array(arrayBuffer); // Encrypt raw bytes const { encryptedData, iv, salt } = await encryptData(bytes, password); // Encrypted payload to bit array const payloadBits = uint8ArrayToBitArray(encryptedData); // Metadata object with Base64 encoding for binary data const metadata = { iv: uint8ArrayToBase64(iv), salt: uint8ArrayToBase64(salt), originalLength: bytes.length, fileName: file.name, fileType: file.type, }; // Metadata to JSON string and then to bit array const metadataStr = JSON.stringify(metadata); const metadataBits = stringToBitArray(metadataStr); // Add 32-bit length header at the start const lengthBits = numberTo32BitArray(metadataBits.length); const fullMetadataBits = [...lengthBits, ...metadataBits]; return { bits: payloadBits, metabits: fullMetadataBits, }; }","map":{"version":3,"names":["encryptData","uint8ArrayToBitArray","bytes","bits","byte","i","push","stringToBitArray","str","length","charCodeAt","j","numberTo32BitArray","num"],"sources":["C:/Users/mesco/OneDrive/Documents/GitHub/S/src/components/ToBinary.js"],"sourcesContent":["// ToBinary.js \r\nimport { encryptData } from \"./ToBlackBox\"; function uint8ArrayToBitArray(bytes) { const bits = []; for (const byte of bytes) { for (let i = 7; i >= 0; i--) { bits.push((byte >> i) & 1); } } return bits; } function stringToBitArray(str) { const bits = []; for (let i = 0; i < str.length; i++) { const byte = str.charCodeAt(i); for (let j = 7; j >= 0; j--) { bits.push((byte >> j) & 1); } } return bits; } function numberTo32BitArray(num) { const bits = []; for (let i = 31; i >= 0; i--) { bits.push((num >> i) & 1); } return bits; } // Helper: Convert Uint8Array to Base64 string function uint8ArrayToBase64(uint8Array) { return btoa(String.fromCharCode(...uint8Array)); } export default async function ToBinary(file, password) { if (!file) throw new Error(\"No file provided\"); if (!password || password.trim() === \"\") throw new Error(\"Password is required for encryption\"); const arrayBuffer = await file.arrayBuffer(); const bytes = new Uint8Array(arrayBuffer); // Encrypt raw bytes const { encryptedData, iv, salt } = await encryptData(bytes, password); // Encrypted payload to bit array const payloadBits = uint8ArrayToBitArray(encryptedData); // Metadata object with Base64 encoding for binary data const metadata = { iv: uint8ArrayToBase64(iv), salt: uint8ArrayToBase64(salt), originalLength: bytes.length, fileName: file.name, fileType: file.type, }; // Metadata to JSON string and then to bit array const metadataStr = JSON.stringify(metadata); const metadataBits = stringToBitArray(metadataStr); // Add 32-bit length header at the start const lengthBits = numberTo32BitArray(metadataBits.length); const fullMetadataBits = [...lengthBits, ...metadataBits]; return { bits: payloadBits, metabits: fullMetadataBits, }; }"],"mappings":"AAAA;AACA,SAASA,WAAW,QAAQ,cAAc;AAAE,SAASC,oBAAoBA,CAACC,KAAK,EAAE;EAAE,MAAMC,IAAI,GAAG,EAAE;EAAE,KAAK,MAAMC,IAAI,IAAIF,KAAK,EAAE;IAAE,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAAEF,IAAI,CAACG,IAAI,CAAEF,IAAI,IAAIC,CAAC,GAAI,CAAC,CAAC;IAAE;EAAE;EAAE,OAAOF,IAAI;AAAE;AAAE,SAASI,gBAAgBA,CAACC,GAAG,EAAE;EAAE,MAAML,IAAI,GAAG,EAAE;EAAE,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,GAAG,CAACC,MAAM,EAAEJ,CAAC,EAAE,EAAE;IAAE,MAAMD,IAAI,GAAGI,GAAG,CAACE,UAAU,CAACL,CAAC,CAAC;IAAE,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAAER,IAAI,CAACG,IAAI,CAAEF,IAAI,IAAIO,CAAC,GAAI,CAAC,CAAC;IAAE;EAAE;EAAE,OAAOR,IAAI;AAAE;AAAE,SAASS,kBAAkBA,CAACC,GAAG,EAAE;EAAE,MAAMV,IAAI,GAAG,EAAE;EAAE,KAAK,IAAIE,CAAC,GAAG,EAAE,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAAEF,IAAI,CAACG,IAAI,CAAEO,GAAG,IAAIR,CAAC,GAAI,CAAC,CAAC;EAAE;EAAE,OAAOF,IAAI;AAAE,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}