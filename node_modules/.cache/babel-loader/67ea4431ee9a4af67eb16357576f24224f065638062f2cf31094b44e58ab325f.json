{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lzw = void 0;\n\n/**\r\n * javascript port of java LZW decompression\r\n * Original java author url: https://gist.github.com/devunwired/4479231\r\n */\nvar lzw = function lzw(minCodeSize, data, pixelCount) {\n  var MAX_STACK_SIZE = 4096;\n  var nullCode = -1;\n  var npix = pixelCount;\n  var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;\n  var dstPixels = new Array(pixelCount);\n  var prefix = new Array(MAX_STACK_SIZE);\n  var suffix = new Array(MAX_STACK_SIZE);\n  var pixelStack = new Array(MAX_STACK_SIZE + 1); // Initialize GIF data stream decoder.\n\n  data_size = minCodeSize;\n  clear = 1 << data_size;\n  end_of_information = clear + 1;\n  available = clear + 2;\n  old_code = nullCode;\n  code_size = data_size + 1;\n  code_mask = (1 << code_size) - 1;\n  for (code = 0; code < clear; code++) {\n    prefix[code] = 0;\n    suffix[code] = code;\n  } // Decode GIF pixel stream.\n\n  var datum, bits, count, first, top, pi, bi;\n  datum = bits = count = first = top = pi = bi = 0;\n  for (i = 0; i < npix;) {\n    if (top === 0) {\n      if (bits < code_size) {\n        // get the next byte\n        datum += data[bi] << bits;\n        bits += 8;\n        bi++;\n        continue;\n      } // Get the next code.\n\n      code = datum & code_mask;\n      datum >>= code_size;\n      bits -= code_size; // Interpret the code\n\n      if (code > available || code == end_of_information) {\n        break;\n      }\n      if (code == clear) {\n        // Reset decoder.\n        code_size = data_size + 1;\n        code_mask = (1 << code_size) - 1;\n        available = clear + 2;\n        old_code = nullCode;\n        continue;\n      }\n      if (old_code == nullCode) {\n        pixelStack[top++] = suffix[code];\n        old_code = code;\n        first = code;\n        continue;\n      }\n      in_code = code;\n      if (code == available) {\n        pixelStack[top++] = first;\n        code = old_code;\n      }\n      while (code > clear) {\n        pixelStack[top++] = suffix[code];\n        code = prefix[code];\n      }\n      first = suffix[code] & 0xff;\n      pixelStack[top++] = first; // add a new string to the table, but only if space is available\n      // if not, just continue with current table until a clear code is found\n      // (deferred clear code implementation as per GIF spec)\n\n      if (available < MAX_STACK_SIZE) {\n        prefix[available] = old_code;\n        suffix[available] = first;\n        available++;\n        if ((available & code_mask) === 0 && available < MAX_STACK_SIZE) {\n          code_size++;\n          code_mask += available;\n        }\n      }\n      old_code = in_code;\n    } // Pop a pixel off the pixel stack.\n\n    top--;\n    dstPixels[pi++] = pixelStack[top];\n    i++;\n  }\n  for (i = pi; i < npix; i++) {\n    dstPixels[i] = 0; // clear missing pixels\n  }\n  return dstPixels;\n};\nexports.lzw = lzw;","map":{"version":3,"names":["Object","defineProperty","exports","value","lzw","minCodeSize","data","pixelCount","MAX_STACK_SIZE","nullCode","npix","available","clear","code_mask","code_size","end_of_information","in_code","old_code","bits","code","i","datum","data_size","first","top","bi","pi","dstPixels","Array","prefix","suffix","pixelStack","count"],"sources":["/Users/melvinescobar/Steganography/node_modules/gifuct-js/lib/lzw.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lzw = void 0;\n\n/**\r\n * javascript port of java LZW decompression\r\n * Original java author url: https://gist.github.com/devunwired/4479231\r\n */\nvar lzw = function lzw(minCodeSize, data, pixelCount) {\n  var MAX_STACK_SIZE = 4096;\n  var nullCode = -1;\n  var npix = pixelCount;\n  var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;\n  var dstPixels = new Array(pixelCount);\n  var prefix = new Array(MAX_STACK_SIZE);\n  var suffix = new Array(MAX_STACK_SIZE);\n  var pixelStack = new Array(MAX_STACK_SIZE + 1); // Initialize GIF data stream decoder.\n\n  data_size = minCodeSize;\n  clear = 1 << data_size;\n  end_of_information = clear + 1;\n  available = clear + 2;\n  old_code = nullCode;\n  code_size = data_size + 1;\n  code_mask = (1 << code_size) - 1;\n\n  for (code = 0; code < clear; code++) {\n    prefix[code] = 0;\n    suffix[code] = code;\n  } // Decode GIF pixel stream.\n\n\n  var datum, bits, count, first, top, pi, bi;\n  datum = bits = count = first = top = pi = bi = 0;\n\n  for (i = 0; i < npix;) {\n    if (top === 0) {\n      if (bits < code_size) {\n        // get the next byte\n        datum += data[bi] << bits;\n        bits += 8;\n        bi++;\n        continue;\n      } // Get the next code.\n\n\n      code = datum & code_mask;\n      datum >>= code_size;\n      bits -= code_size; // Interpret the code\n\n      if (code > available || code == end_of_information) {\n        break;\n      }\n\n      if (code == clear) {\n        // Reset decoder.\n        code_size = data_size + 1;\n        code_mask = (1 << code_size) - 1;\n        available = clear + 2;\n        old_code = nullCode;\n        continue;\n      }\n\n      if (old_code == nullCode) {\n        pixelStack[top++] = suffix[code];\n        old_code = code;\n        first = code;\n        continue;\n      }\n\n      in_code = code;\n\n      if (code == available) {\n        pixelStack[top++] = first;\n        code = old_code;\n      }\n\n      while (code > clear) {\n        pixelStack[top++] = suffix[code];\n        code = prefix[code];\n      }\n\n      first = suffix[code] & 0xff;\n      pixelStack[top++] = first; // add a new string to the table, but only if space is available\n      // if not, just continue with current table until a clear code is found\n      // (deferred clear code implementation as per GIF spec)\n\n      if (available < MAX_STACK_SIZE) {\n        prefix[available] = old_code;\n        suffix[available] = first;\n        available++;\n\n        if ((available & code_mask) === 0 && available < MAX_STACK_SIZE) {\n          code_size++;\n          code_mask += available;\n        }\n      }\n\n      old_code = in_code;\n    } // Pop a pixel off the pixel stack.\n\n\n    top--;\n    dstPixels[pi++] = pixelStack[top];\n    i++;\n  }\n\n  for (i = pi; i < npix; i++) {\n    dstPixels[i] = 0; // clear missing pixels\n  }\n\n  return dstPixels;\n};\n\nexports.lzw = lzw;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}