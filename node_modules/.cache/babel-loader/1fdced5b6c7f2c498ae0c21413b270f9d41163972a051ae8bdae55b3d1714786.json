{"ast":null,"code":"// FromBinary.js\nimport { decryptData } from \"./ToBlackBox\";\nfunction binaryToUint8Array(binStr) {\n  const bytes = [];\n  for (let i = 0; i < binStr.length; i += 8) {\n    const byte = binStr.slice(i, i + 8);\n    bytes.push(parseInt(byte, 2));\n  }\n  return new Uint8Array(bytes);\n}\nexport default async function FromBinary(encryptedBits, metadataBits, password) {\n  if (!encryptedBits) throw new Error(\"No encrypted bits provided\");\n  if (!metadataBits) throw new Error(\"No metadata bits provided\");\n  if (!password || password.trim() === \"\") throw new Error(\"Password is required\");\n\n  // --- Step 1: Extract metadata length ---\n  const lengthBits = metadataBits.slice(0, 32);\n  const metadataLength = parseInt(lengthBits, 2);\n\n  // --- Step 2: Extract actual metadata bits ---\n  const actualMetadataBits = metadataBits.slice(32, 32 + metadataLength);\n\n  // --- Step 3: Convert metadata binary to string ---\n  let metadataStr = '';\n  for (let i = 0; i < actualMetadataBits.length; i += 8) {\n    const byte = actualMetadataBits.slice(i, i + 8);\n    metadataStr += String.fromCharCode(parseInt(byte, 2));\n  }\n\n  // --- Step 4: Parse metadata JSON ---\n  let metadata;\n  try {\n    metadata = JSON.parse(metadataStr);\n  } catch (err) {\n    throw new Error(\"Failed to parse metadata JSON: \" + err.message);\n  }\n  const {\n    iv,\n    salt,\n    originalLength,\n    fileName,\n    fileType\n  } = metadata;\n\n  // --- Step 5: Convert encrypted bits to Uint8Array ---\n  const encryptedDataArray = binaryToUint8Array(encryptedBits);\n\n  // --- Step 6: Decrypt using password, IV, and salt ---\n  const decryptedBinary = await decryptData(encryptedDataArray, password, iv, salt);\n\n  // --- Step 7: Convert decrypted binary string to Uint8Array ---\n  const originalBytes = binaryToUint8Array(decryptedBinary);\n\n  // --- Step 8: Return Blob and fileName for download ---\n  return {\n    blob: new Blob([originalBytes], {\n      type: fileType\n    }),\n    fileName\n  };\n}\n_c = FromBinary;\nvar _c;\n$RefreshReg$(_c, \"FromBinary\");","map":{"version":3,"names":["decryptData","binaryToUint8Array","binStr","bytes","i","length","byte","slice","push","parseInt","Uint8Array","FromBinary","encryptedBits","metadataBits","password","Error","trim","lengthBits","metadataLength","actualMetadataBits","metadataStr","String","fromCharCode","metadata","JSON","parse","err","message","iv","salt","originalLength","fileName","fileType","encryptedDataArray","decryptedBinary","originalBytes","blob","Blob","type","_c","$RefreshReg$"],"sources":["C:/Users/mesco/OneDrive/Documents/GitHub/S/src/components/ToExtract.js"],"sourcesContent":["// FromBinary.js\r\nimport { decryptData } from \"./ToBlackBox\";\r\n\r\nfunction binaryToUint8Array(binStr) {\r\n    const bytes = [];\r\n    for (let i = 0; i < binStr.length; i += 8) {\r\n        const byte = binStr.slice(i, i + 8);\r\n        bytes.push(parseInt(byte, 2));\r\n    }\r\n    return new Uint8Array(bytes);\r\n}\r\n\r\nexport default async function FromBinary(encryptedBits, metadataBits, password) {\r\n    if (!encryptedBits) throw new Error(\"No encrypted bits provided\");\r\n    if (!metadataBits) throw new Error(\"No metadata bits provided\");\r\n    if (!password || password.trim() === \"\") throw new Error(\"Password is required\");\r\n\r\n    // --- Step 1: Extract metadata length ---\r\n    const lengthBits = metadataBits.slice(0, 32);\r\n    const metadataLength = parseInt(lengthBits, 2);\r\n\r\n    // --- Step 2: Extract actual metadata bits ---\r\n    const actualMetadataBits = metadataBits.slice(32, 32 + metadataLength);\r\n\r\n    // --- Step 3: Convert metadata binary to string ---\r\n    let metadataStr = '';\r\n    for (let i = 0; i < actualMetadataBits.length; i += 8) {\r\n        const byte = actualMetadataBits.slice(i, i + 8);\r\n        metadataStr += String.fromCharCode(parseInt(byte, 2));\r\n    }\r\n\r\n    // --- Step 4: Parse metadata JSON ---\r\n    let metadata;\r\n    try {\r\n        metadata = JSON.parse(metadataStr);\r\n    } catch (err) {\r\n        throw new Error(\"Failed to parse metadata JSON: \" + err.message);\r\n    }\r\n\r\n    const { iv, salt, originalLength, fileName, fileType } = metadata;\r\n\r\n    // --- Step 5: Convert encrypted bits to Uint8Array ---\r\n    const encryptedDataArray = binaryToUint8Array(encryptedBits);\r\n\r\n    // --- Step 6: Decrypt using password, IV, and salt ---\r\n    const decryptedBinary = await decryptData(encryptedDataArray, password, iv, salt);\r\n\r\n    // --- Step 7: Convert decrypted binary string to Uint8Array ---\r\n    const originalBytes = binaryToUint8Array(decryptedBinary);\r\n\r\n    // --- Step 8: Return Blob and fileName for download ---\r\n    return { blob: new Blob([originalBytes], { type: fileType }), fileName };\r\n}\r\n"],"mappings":"AAAA;AACA,SAASA,WAAW,QAAQ,cAAc;AAE1C,SAASC,kBAAkBA,CAACC,MAAM,EAAE;EAChC,MAAMC,KAAK,GAAG,EAAE;EAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,CAACG,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IACvC,MAAME,IAAI,GAAGJ,MAAM,CAACK,KAAK,CAACH,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;IACnCD,KAAK,CAACK,IAAI,CAACC,QAAQ,CAACH,IAAI,EAAE,CAAC,CAAC,CAAC;EACjC;EACA,OAAO,IAAII,UAAU,CAACP,KAAK,CAAC;AAChC;AAEA,eAAe,eAAeQ,UAAUA,CAACC,aAAa,EAAEC,YAAY,EAAEC,QAAQ,EAAE;EAC5E,IAAI,CAACF,aAAa,EAAE,MAAM,IAAIG,KAAK,CAAC,4BAA4B,CAAC;EACjE,IAAI,CAACF,YAAY,EAAE,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;EAC/D,IAAI,CAACD,QAAQ,IAAIA,QAAQ,CAACE,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,MAAM,IAAID,KAAK,CAAC,sBAAsB,CAAC;;EAEhF;EACA,MAAME,UAAU,GAAGJ,YAAY,CAACN,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EAC5C,MAAMW,cAAc,GAAGT,QAAQ,CAACQ,UAAU,EAAE,CAAC,CAAC;;EAE9C;EACA,MAAME,kBAAkB,GAAGN,YAAY,CAACN,KAAK,CAAC,EAAE,EAAE,EAAE,GAAGW,cAAc,CAAC;;EAEtE;EACA,IAAIE,WAAW,GAAG,EAAE;EACpB,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,kBAAkB,CAACd,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IACnD,MAAME,IAAI,GAAGa,kBAAkB,CAACZ,KAAK,CAACH,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;IAC/CgB,WAAW,IAAIC,MAAM,CAACC,YAAY,CAACb,QAAQ,CAACH,IAAI,EAAE,CAAC,CAAC,CAAC;EACzD;;EAEA;EACA,IAAIiB,QAAQ;EACZ,IAAI;IACAA,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACL,WAAW,CAAC;EACtC,CAAC,CAAC,OAAOM,GAAG,EAAE;IACV,MAAM,IAAIX,KAAK,CAAC,iCAAiC,GAAGW,GAAG,CAACC,OAAO,CAAC;EACpE;EAEA,MAAM;IAAEC,EAAE;IAAEC,IAAI;IAAEC,cAAc;IAAEC,QAAQ;IAAEC;EAAS,CAAC,GAAGT,QAAQ;;EAEjE;EACA,MAAMU,kBAAkB,GAAGhC,kBAAkB,CAACW,aAAa,CAAC;;EAE5D;EACA,MAAMsB,eAAe,GAAG,MAAMlC,WAAW,CAACiC,kBAAkB,EAAEnB,QAAQ,EAAEc,EAAE,EAAEC,IAAI,CAAC;;EAEjF;EACA,MAAMM,aAAa,GAAGlC,kBAAkB,CAACiC,eAAe,CAAC;;EAEzD;EACA,OAAO;IAAEE,IAAI,EAAE,IAAIC,IAAI,CAAC,CAACF,aAAa,CAAC,EAAE;MAAEG,IAAI,EAAEN;IAAS,CAAC,CAAC;IAAED;EAAS,CAAC;AAC5E;AAACQ,EAAA,GAxC6B5B,UAAU;AAAA,IAAA4B,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}