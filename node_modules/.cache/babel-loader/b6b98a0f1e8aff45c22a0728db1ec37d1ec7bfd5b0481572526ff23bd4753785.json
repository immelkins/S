{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\mesco\\\\OneDrive\\\\Documents\\\\GitHub\\\\S\\\\src\\\\components\\\\Decryption.js\",\n  _s = $RefreshSig$();\n// Decryption.js\n/*\r\nimport { useState } from \"react\";\r\nimport ToBits from \"./ToBits\";\r\nimport { decryptData } from './ToBlackBox';\r\n\r\nconst HEADER_BITS = [1, 0, 1, 0, 1, 0, 1, 1];\r\n\r\nfunction bitArrayToString(bits) {\r\n\tconst bytes = [];\r\n\tfor (let i = 0; i < bits.length; i += 8) {\r\n\t\tlet byte = 0;\r\n\t\tfor (let j = 0; j < 8; j++) {\r\n\t\t\tbyte = (byte << 1) | (bits[i + j] || 0);\r\n\t\t}\r\n\t\tbytes.push(byte);\r\n\t}\r\n\tconst decoder = new TextDecoder('utf-8');\r\n\treturn decoder.decode(new Uint8Array(bytes));\r\n}\r\n\r\nfunction bitArrayToUint8Array(bits) {\r\n\tconst bytes = [];\r\n\tfor (let i = 0; i < bits.length; i += 8) {\r\n\t\tlet byte = 0;\r\n\t\tfor (let j = 0; j < 8; j++) {\r\n\t\t\tbyte = (byte << 1) | (bits[i + j] || 0);\r\n\t\t}\r\n\t\tbytes.push(byte);\r\n\t}\r\n\treturn new Uint8Array(bytes);\r\n}\r\n\r\nfunction base64ToUint8Array(base64) {\r\n\treturn Uint8Array.from(atob(base64), c => c.charCodeAt(0));\r\n}\r\n\r\nexport default function Decryption() {\r\n\tconst [gifFile, setGifFile] = useState(null);\r\n\tconst [frames, setFrames] = useState([]);\r\n\tconst [error, setError] = useState(null);\r\n\tconst [password, setPassword] = useState(\"\");\r\n\r\n\tconst handleGIFChange = (e) => {\r\n\t\tconst file = e.target.files[0];\r\n\t\tif (!file) return;\r\n\t\tsetGifFile(file);\r\n\r\n\t\tToBits(file)\r\n\t\t\t.then(({ frames }) => setFrames(frames))\r\n\t\t\t.catch(err => setError(err.message));\r\n\t};\r\n\r\n\tconst handleExtractBinary = async () => {\r\n\t\tif (!frames.length) return;\r\n\t\tif (!password) {\r\n\t\t\tsetError(\"Password is required\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst allBits = [];\r\n\t\tfor (let frameIndex = 0; frameIndex < frames.length; frameIndex++) {\r\n\t\t\tconst patch = frames[frameIndex].patch;\r\n\t\t\tfor (let i = 0; i < patch.length; i += 4) {\r\n\t\t\t\tallBits.push(patch[i + 2] & 1); // LSB of blue channel\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Check header\r\n\t\tfor (let i = 0; i < HEADER_BITS.length; i++) {\r\n\t\t\tif (allBits[i] !== HEADER_BITS[i]) {\r\n\t\t\t\tsetError(\"Header not found in GIF.\");\r\n\t\t\t\tconsole.warn(\"Header read:\", allBits.slice(0, HEADER_BITS.length));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Extract metadata length\r\n\t\tconst metadataLengthBits = allBits.slice(HEADER_BITS.length, HEADER_BITS.length + 32);\r\n\t\tconst metadataLength = parseInt(metadataLengthBits.join(''), 2);\r\n\r\n\t\t// Extract metadata and payload\r\n\t\tconst metadataBits = allBits.slice(HEADER_BITS.length + 32, HEADER_BITS.length + 32 + metadataLength);\r\n\t\tconst payloadBits = allBits.slice(HEADER_BITS.length + 32 + metadataLength);\r\n\r\n\t\t// Convert metadata bits to string\r\n\t\tconst metadataText = bitArrayToString(metadataBits);\r\n\r\n\t\t// Now metadataText should be valid JSON if ToBinary stored Base64 IV/salt\r\n\t\tlet metadata;\r\n\t\ttry {\r\n\t\t\tmetadata = JSON.parse(metadataText);\r\n\t\t} catch (err) {\r\n\t\t\tconsole.error(\"Failed to parse metadata JSON:\", err);\r\n\t\t\tconsole.log(\"Metadata text:\", metadataText); // <-- inspect raw string\r\n\t\t\tsetError(\"Failed to parse metadata JSON.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconsole.log(\"Raw metadata text:\", metadataText);\r\n\r\n\t\t// Convert payload bits to Uint8Array ready for decryption\r\n\t\tconst encryptedBytes = bitArrayToUint8Array(payloadBits);\r\n\t\tconsole.log(\"Encrypted payload length:\", encryptedBytes.length);\r\n\r\n\t\t// Decode IV and salt for decryption\r\n\t\tconst ivArray = base64ToUint8Array(metadata.iv);\r\n\t\tconst saltArray = base64ToUint8Array(metadata.salt);\r\n\t\tconsole.log(\"IV:\", ivArray);\r\n\t\tconsole.log(\"Salt:\", saltArray);\r\n\r\n\r\n\t\tconst ivBuffer = ivArray.buffer;\r\n\t\tconst saltBuffer = saltArray.buffer;\r\n\t\tconsole.log(\"IV:\", ivBuffer);\r\n\t\tconsole.log(\"Salt:\", saltBuffer);\r\n\r\n\t\ttry {\r\n\t\t\tconst decryptedData = await decryptData(encryptedBytes, password, ivBuffer, saltBuffer);\r\n\t\t\tconsole.log(\"Decrypted data:\", decryptedData);\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error(\"Decryption failed:\", error);\r\n\t\t\tsetError(\"Decryption failed. Check password and try again.\");\r\n\t\t}\r\n\t};\r\n\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t<h2>Decrypt GIF Binary Data</h2>\r\n\t\t\t<input type=\"file\" accept=\"image/gif\" onChange={handleGIFChange} />\r\n\t\t\t{gifFile && <p>Uploaded GIF: {gifFile.name}</p>}\r\n\t\t\t<input type=\"password\" placeholder=\"Password\" value={password} onChange={(e) => setPassword(e.target.value)} />\r\n\t\t\t{frames.length > 0 && <button onClick={handleExtractBinary}>Extract Binary Data</button>}\r\n\t\t\t{error && <p className=\"error\">{error}</p>}\r\n\t\t</div>\r\n\t);\r\n}\r\n*/\nimport { useState } from \"react\";\nimport ToBits from \"./ToBits\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HEADER_BITS = [1, 0, 1, 0, 1, 0, 1, 1]; // sync header\n\n// Convert bit array → \"010101...\"\nfunction bitArrayToBitString(bits) {\n  return bits.join(\"\");\n}\n\n// Download text file\nfunction downloadText(text, filename) {\n  const blob = new Blob([text], {\n    type: \"text/plain\"\n  });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  document.body.appendChild(a);\n  a.click();\n  URL.revokeObjectURL(url);\n  document.body.removeChild(a);\n}\nexport default function Decryption() {\n  _s();\n  const [gifFile, setGifFile] = useState(null);\n  const [frames, setFrames] = useState([]);\n  const [error, setError] = useState(null);\n  const handleGIFChange = e => {\n    const file = e.target.files[0];\n    if (!file) return;\n    setGifFile(file);\n    setError(null);\n    ToBits(file).then(({\n      frames\n    }) => setFrames(frames)).catch(err => setError(err.message));\n  };\n  const handleExtractBinary = () => {\n    if (!frames.length) return;\n\n    // 1️⃣ Read all LSBs (blue channel)\n    const allBits = [];\n    for (const frame of frames) {\n      const patch = frame.patch;\n      for (let i = 0; i < patch.length; i += 4) {\n        allBits.push(patch[i + 2] & 1);\n      }\n    }\n\n    // 2️⃣ Verify header\n    for (let i = 0; i < HEADER_BITS.length; i++) {\n      if (allBits[i] !== HEADER_BITS[i]) {\n        console.warn(\"Header read:\", allBits.slice(0, HEADER_BITS.length));\n        setError(\"Header not found in GIF.\");\n        return;\n      }\n    }\n\n    // 3️⃣ Extract metadata length (32 bits)\n    const metadataLengthBits = allBits.slice(HEADER_BITS.length, HEADER_BITS.length + 32);\n    const metadataLength = parseInt(metadataLengthBits.join(\"\"), 2);\n    if (!metadataLength || metadataLength <= 0) {\n      setError(\"Invalid metadata length.\");\n      return;\n    }\n\n    // 4️⃣ Extract metadata\n    const metadataStart = HEADER_BITS.length + 32;\n    const metadataEnd = metadataStart + metadataLength;\n    const metadataBits = allBits.slice(metadataStart, metadataEnd);\n\n    // 5️⃣ Extract payload\n    const payloadBits = allBits.slice(metadataEnd);\n\n    // 6️⃣ HEADER + LENGTH + METADATA\n    const metadataWithHeader = [...HEADER_BITS, ...metadataLengthBits, ...metadataBits];\n\n    // 7️⃣ HEADER + LENGTH + METADATA + PAYLOAD\n    const fullBits = [...HEADER_BITS, ...metadataLengthBits, ...metadataBits, ...payloadBits];\n\n    // 8️⃣ Export files\n    downloadText(bitArrayToBitString(metadataWithHeader), \"metadata_bits.txt\");\n    downloadText(bitArrayToBitString(fullBits), \"full_bits.txt\");\n    console.log(\"Header bits:\", HEADER_BITS.length);\n    console.log(\"Metadata bits:\", metadataBits.length);\n    console.log(\"Payload bits:\", payloadBits.length);\n    console.log(\"Export complete\");\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Extract GIF LSB Bitstream\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 256,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n      type: \"file\",\n      accept: \"image/gif\",\n      onChange: handleGIFChange\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 258,\n      columnNumber: 7\n    }, this), gifFile && /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"Uploaded GIF: \", gifFile.name]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 260,\n      columnNumber: 19\n    }, this), frames.length > 0 && /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleExtractBinary,\n      children: \"Export Bitstreams\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 263,\n      columnNumber: 9\n    }, this), error && /*#__PURE__*/_jsxDEV(\"p\", {\n      className: \"error\",\n      children: error\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 268,\n      columnNumber: 17\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 255,\n    columnNumber: 5\n  }, this);\n}\n_s(Decryption, \"aeOGrsnha26wU2/8KfGh0KlPnas=\");\n_c = Decryption;\nvar _c;\n$RefreshReg$(_c, \"Decryption\");","map":{"version":3,"names":["useState","ToBits","jsxDEV","_jsxDEV","HEADER_BITS","bitArrayToBitString","bits","join","downloadText","text","filename","blob","Blob","type","url","URL","createObjectURL","a","document","createElement","href","download","body","appendChild","click","revokeObjectURL","removeChild","Decryption","_s","gifFile","setGifFile","frames","setFrames","error","setError","handleGIFChange","e","file","target","files","then","catch","err","message","handleExtractBinary","length","allBits","frame","patch","i","push","console","warn","slice","metadataLengthBits","metadataLength","parseInt","metadataStart","metadataEnd","metadataBits","payloadBits","metadataWithHeader","fullBits","log","children","fileName","_jsxFileName","lineNumber","columnNumber","accept","onChange","name","onClick","className","_c","$RefreshReg$"],"sources":["C:/Users/mesco/OneDrive/Documents/GitHub/S/src/components/Decryption.js"],"sourcesContent":["// Decryption.js\r\n/*\r\nimport { useState } from \"react\";\r\nimport ToBits from \"./ToBits\";\r\nimport { decryptData } from './ToBlackBox';\r\n\r\nconst HEADER_BITS = [1, 0, 1, 0, 1, 0, 1, 1];\r\n\r\nfunction bitArrayToString(bits) {\r\n\tconst bytes = [];\r\n\tfor (let i = 0; i < bits.length; i += 8) {\r\n\t\tlet byte = 0;\r\n\t\tfor (let j = 0; j < 8; j++) {\r\n\t\t\tbyte = (byte << 1) | (bits[i + j] || 0);\r\n\t\t}\r\n\t\tbytes.push(byte);\r\n\t}\r\n\tconst decoder = new TextDecoder('utf-8');\r\n\treturn decoder.decode(new Uint8Array(bytes));\r\n}\r\n\r\nfunction bitArrayToUint8Array(bits) {\r\n\tconst bytes = [];\r\n\tfor (let i = 0; i < bits.length; i += 8) {\r\n\t\tlet byte = 0;\r\n\t\tfor (let j = 0; j < 8; j++) {\r\n\t\t\tbyte = (byte << 1) | (bits[i + j] || 0);\r\n\t\t}\r\n\t\tbytes.push(byte);\r\n\t}\r\n\treturn new Uint8Array(bytes);\r\n}\r\n\r\nfunction base64ToUint8Array(base64) {\r\n\treturn Uint8Array.from(atob(base64), c => c.charCodeAt(0));\r\n}\r\n\r\nexport default function Decryption() {\r\n\tconst [gifFile, setGifFile] = useState(null);\r\n\tconst [frames, setFrames] = useState([]);\r\n\tconst [error, setError] = useState(null);\r\n\tconst [password, setPassword] = useState(\"\");\r\n\r\n\tconst handleGIFChange = (e) => {\r\n\t\tconst file = e.target.files[0];\r\n\t\tif (!file) return;\r\n\t\tsetGifFile(file);\r\n\r\n\t\tToBits(file)\r\n\t\t\t.then(({ frames }) => setFrames(frames))\r\n\t\t\t.catch(err => setError(err.message));\r\n\t};\r\n\r\n\tconst handleExtractBinary = async () => {\r\n\t\tif (!frames.length) return;\r\n\t\tif (!password) {\r\n\t\t\tsetError(\"Password is required\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst allBits = [];\r\n\t\tfor (let frameIndex = 0; frameIndex < frames.length; frameIndex++) {\r\n\t\t\tconst patch = frames[frameIndex].patch;\r\n\t\t\tfor (let i = 0; i < patch.length; i += 4) {\r\n\t\t\t\tallBits.push(patch[i + 2] & 1); // LSB of blue channel\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Check header\r\n\t\tfor (let i = 0; i < HEADER_BITS.length; i++) {\r\n\t\t\tif (allBits[i] !== HEADER_BITS[i]) {\r\n\t\t\t\tsetError(\"Header not found in GIF.\");\r\n\t\t\t\tconsole.warn(\"Header read:\", allBits.slice(0, HEADER_BITS.length));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Extract metadata length\r\n\t\tconst metadataLengthBits = allBits.slice(HEADER_BITS.length, HEADER_BITS.length + 32);\r\n\t\tconst metadataLength = parseInt(metadataLengthBits.join(''), 2);\r\n\r\n\t\t// Extract metadata and payload\r\n\t\tconst metadataBits = allBits.slice(HEADER_BITS.length + 32, HEADER_BITS.length + 32 + metadataLength);\r\n\t\tconst payloadBits = allBits.slice(HEADER_BITS.length + 32 + metadataLength);\r\n\r\n\t\t// Convert metadata bits to string\r\n\t\tconst metadataText = bitArrayToString(metadataBits);\r\n\r\n\t\t// Now metadataText should be valid JSON if ToBinary stored Base64 IV/salt\r\n\t\tlet metadata;\r\n\t\ttry {\r\n\t\t\tmetadata = JSON.parse(metadataText);\r\n\t\t} catch (err) {\r\n\t\t\tconsole.error(\"Failed to parse metadata JSON:\", err);\r\n\t\t\tconsole.log(\"Metadata text:\", metadataText); // <-- inspect raw string\r\n\t\t\tsetError(\"Failed to parse metadata JSON.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconsole.log(\"Raw metadata text:\", metadataText);\r\n\r\n\t\t// Convert payload bits to Uint8Array ready for decryption\r\n\t\tconst encryptedBytes = bitArrayToUint8Array(payloadBits);\r\n\t\tconsole.log(\"Encrypted payload length:\", encryptedBytes.length);\r\n\r\n\t\t// Decode IV and salt for decryption\r\n\t\tconst ivArray = base64ToUint8Array(metadata.iv);\r\n\t\tconst saltArray = base64ToUint8Array(metadata.salt);\r\n\t\tconsole.log(\"IV:\", ivArray);\r\n\t\tconsole.log(\"Salt:\", saltArray);\r\n\r\n\r\n\t\tconst ivBuffer = ivArray.buffer;\r\n\t\tconst saltBuffer = saltArray.buffer;\r\n\t\tconsole.log(\"IV:\", ivBuffer);\r\n\t\tconsole.log(\"Salt:\", saltBuffer);\r\n\r\n\t\ttry {\r\n\t\t\tconst decryptedData = await decryptData(encryptedBytes, password, ivBuffer, saltBuffer);\r\n\t\t\tconsole.log(\"Decrypted data:\", decryptedData);\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error(\"Decryption failed:\", error);\r\n\t\t\tsetError(\"Decryption failed. Check password and try again.\");\r\n\t\t}\r\n\t};\r\n\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t<h2>Decrypt GIF Binary Data</h2>\r\n\t\t\t<input type=\"file\" accept=\"image/gif\" onChange={handleGIFChange} />\r\n\t\t\t{gifFile && <p>Uploaded GIF: {gifFile.name}</p>}\r\n\t\t\t<input type=\"password\" placeholder=\"Password\" value={password} onChange={(e) => setPassword(e.target.value)} />\r\n\t\t\t{frames.length > 0 && <button onClick={handleExtractBinary}>Extract Binary Data</button>}\r\n\t\t\t{error && <p className=\"error\">{error}</p>}\r\n\t\t</div>\r\n\t);\r\n}\r\n*/\r\nimport { useState } from \"react\";\r\nimport ToBits from \"./ToBits\";\r\n\r\nconst HEADER_BITS = [1, 0, 1, 0, 1, 0, 1, 1]; // sync header\r\n\r\n// Convert bit array → \"010101...\"\r\nfunction bitArrayToBitString(bits) {\r\n  return bits.join(\"\");\r\n}\r\n\r\n// Download text file\r\nfunction downloadText(text, filename) {\r\n  const blob = new Blob([text], { type: \"text/plain\" });\r\n  const url = URL.createObjectURL(blob);\r\n\r\n  const a = document.createElement(\"a\");\r\n  a.href = url;\r\n  a.download = filename;\r\n  document.body.appendChild(a);\r\n  a.click();\r\n\r\n  URL.revokeObjectURL(url);\r\n  document.body.removeChild(a);\r\n}\r\n\r\nexport default function Decryption() {\r\n  const [gifFile, setGifFile] = useState(null);\r\n  const [frames, setFrames] = useState([]);\r\n  const [error, setError] = useState(null);\r\n\r\n  const handleGIFChange = (e) => {\r\n    const file = e.target.files[0];\r\n    if (!file) return;\r\n\r\n    setGifFile(file);\r\n    setError(null);\r\n\r\n    ToBits(file)\r\n      .then(({ frames }) => setFrames(frames))\r\n      .catch(err => setError(err.message));\r\n  };\r\n\r\n  const handleExtractBinary = () => {\r\n    if (!frames.length) return;\r\n\r\n    // 1️⃣ Read all LSBs (blue channel)\r\n    const allBits = [];\r\n    for (const frame of frames) {\r\n      const patch = frame.patch;\r\n      for (let i = 0; i < patch.length; i += 4) {\r\n        allBits.push(patch[i + 2] & 1);\r\n      }\r\n    }\r\n\r\n    // 2️⃣ Verify header\r\n    for (let i = 0; i < HEADER_BITS.length; i++) {\r\n      if (allBits[i] !== HEADER_BITS[i]) {\r\n        console.warn(\"Header read:\", allBits.slice(0, HEADER_BITS.length));\r\n        setError(\"Header not found in GIF.\");\r\n        return;\r\n      }\r\n    }\r\n\r\n    // 3️⃣ Extract metadata length (32 bits)\r\n    const metadataLengthBits = allBits.slice(\r\n      HEADER_BITS.length,\r\n      HEADER_BITS.length + 32\r\n    );\r\n    const metadataLength = parseInt(metadataLengthBits.join(\"\"), 2);\r\n\r\n    if (!metadataLength || metadataLength <= 0) {\r\n      setError(\"Invalid metadata length.\");\r\n      return;\r\n    }\r\n\r\n    // 4️⃣ Extract metadata\r\n    const metadataStart = HEADER_BITS.length + 32;\r\n    const metadataEnd = metadataStart + metadataLength;\r\n    const metadataBits = allBits.slice(metadataStart, metadataEnd);\r\n\r\n    // 5️⃣ Extract payload\r\n    const payloadBits = allBits.slice(metadataEnd);\r\n\r\n    // 6️⃣ HEADER + LENGTH + METADATA\r\n    const metadataWithHeader = [\r\n      ...HEADER_BITS,\r\n      ...metadataLengthBits,\r\n      ...metadataBits\r\n    ];\r\n\r\n    // 7️⃣ HEADER + LENGTH + METADATA + PAYLOAD\r\n    const fullBits = [\r\n      ...HEADER_BITS,\r\n      ...metadataLengthBits,\r\n      ...metadataBits,\r\n      ...payloadBits\r\n    ];\r\n\r\n    // 8️⃣ Export files\r\n    downloadText(\r\n      bitArrayToBitString(metadataWithHeader),\r\n      \"metadata_bits.txt\"\r\n    );\r\n\r\n    downloadText(\r\n      bitArrayToBitString(fullBits),\r\n      \"full_bits.txt\"\r\n    );\r\n\r\n    console.log(\"Header bits:\", HEADER_BITS.length);\r\n    console.log(\"Metadata bits:\", metadataBits.length);\r\n    console.log(\"Payload bits:\", payloadBits.length);\r\n    console.log(\"Export complete\");\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <h2>Extract GIF LSB Bitstream</h2>\r\n\r\n      <input type=\"file\" accept=\"image/gif\" onChange={handleGIFChange} />\r\n\r\n      {gifFile && <p>Uploaded GIF: {gifFile.name}</p>}\r\n\r\n      {frames.length > 0 && (\r\n        <button onClick={handleExtractBinary}>\r\n          Export Bitstreams\r\n        </button>\r\n      )}\r\n\r\n      {error && <p className=\"error\">{error}</p>}\r\n    </div>\r\n  );\r\n}\r\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAQ,QAAQ,OAAO;AAChC,OAAOC,MAAM,MAAM,UAAU;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE9B,MAAMC,WAAW,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;;AAE9C;AACA,SAASC,mBAAmBA,CAACC,IAAI,EAAE;EACjC,OAAOA,IAAI,CAACC,IAAI,CAAC,EAAE,CAAC;AACtB;;AAEA;AACA,SAASC,YAAYA,CAACC,IAAI,EAAEC,QAAQ,EAAE;EACpC,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAAC,CAACH,IAAI,CAAC,EAAE;IAAEI,IAAI,EAAE;EAAa,CAAC,CAAC;EACrD,MAAMC,GAAG,GAAGC,GAAG,CAACC,eAAe,CAACL,IAAI,CAAC;EAErC,MAAMM,CAAC,GAAGC,QA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}