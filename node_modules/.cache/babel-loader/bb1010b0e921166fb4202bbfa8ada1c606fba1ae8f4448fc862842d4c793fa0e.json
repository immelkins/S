{"ast":null,"code":"import { decryptData } from \"./ToBlackBox\";\nfunction binaryToUint8Array(binStr) {\n  const bytes = [];\n  for (let i = 0; i < binStr.length; i += 8) {\n    bytes.push(parseInt(binStr.slice(i, i + 8), 2));\n  }\n  return new Uint8Array(bytes);\n}\nexport default async function FromBinary(encryptedBits, metadataBits, password) {\n  if (!encryptedBits) throw new Error(\"No encrypted bits provided\");\n  if (!metadataBits) throw new Error(\"No metadata bits provided\");\n  if (!password || password.trim() === \"\") throw new Error(\"Password is required\");\n\n  // Extract metadata length (first 32 bits)\n  const lengthBits = metadataBits.slice(0, 32);\n  const metadataLength = parseInt(lengthBits, 2);\n\n  // Get actual metadata bits\n  const actualMetadataBits = metadataBits.slice(32, 32 + metadataLength);\n\n  // Convert metadata binary back to string\n  let metadataStr = '';\n  for (let i = 0; i < actualMetadataBits.length; i += 8) {\n    const byte = actualMetadataBits.slice(i, i + 8);\n    metadataStr += String.fromCharCode(parseInt(byte, 2));\n  }\n  const metadata = JSON.parse(metadataStr);\n  const {\n    iv,\n    salt,\n    originalLength,\n    fileName,\n    fileType\n  } = metadata;\n\n  // Convert encrypted bits back to Uint8Array\n  const encryptedDataArray = binaryToUint8Array(encryptedBits);\n\n  // Decrypt using password, iv, and salt\n  const decryptedBinary = await decryptData(encryptedDataArray, password, iv, salt);\n\n  // Convert binary string back to Uint8Array\n  const originalBytes = binaryToUint8Array(decryptedBinary);\n\n  // Return Blob for download\n  return {\n    blob: new Blob([originalBytes], {\n      type: fileType\n    }),\n    fileName\n  };\n}\n_c = FromBinary;\nvar _c;\n$RefreshReg$(_c, \"FromBinary\");","map":{"version":3,"names":["decryptData","binaryToUint8Array","binStr","bytes","i","length","push","parseInt","slice","Uint8Array","FromBinary","encryptedBits","metadataBits","password","Error","trim","lengthBits","metadataLength","actualMetadataBits","metadataStr","byte","String","fromCharCode","metadata","JSON","parse","iv","salt","originalLength","fileName","fileType","encryptedDataArray","decryptedBinary","originalBytes","blob","Blob","type","_c","$RefreshReg$"],"sources":["C:/Users/mesco/OneDrive/Documents/GitHub/S/src/components/ToExtract.js"],"sourcesContent":["import { decryptData } from \"./ToBlackBox\";\r\n\r\nfunction binaryToUint8Array(binStr) {\r\n    const bytes = [];\r\n    for (let i = 0; i < binStr.length; i += 8) {\r\n        bytes.push(parseInt(binStr.slice(i, i + 8), 2));\r\n    }\r\n    return new Uint8Array(bytes);\r\n}\r\n\r\nexport default async function FromBinary(encryptedBits, metadataBits, password) {\r\n    if (!encryptedBits) throw new Error(\"No encrypted bits provided\");\r\n    if (!metadataBits) throw new Error(\"No metadata bits provided\");\r\n    if (!password || password.trim() === \"\") throw new Error(\"Password is required\");\r\n\r\n    // Extract metadata length (first 32 bits)\r\n    const lengthBits = metadataBits.slice(0, 32);\r\n    const metadataLength = parseInt(lengthBits, 2);\r\n\r\n    // Get actual metadata bits\r\n    const actualMetadataBits = metadataBits.slice(32, 32 + metadataLength);\r\n\r\n    // Convert metadata binary back to string\r\n    let metadataStr = '';\r\n    for (let i = 0; i < actualMetadataBits.length; i += 8) {\r\n        const byte = actualMetadataBits.slice(i, i + 8);\r\n        metadataStr += String.fromCharCode(parseInt(byte, 2));\r\n    }\r\n\r\n    const metadata = JSON.parse(metadataStr);\r\n    const { iv, salt, originalLength, fileName, fileType } = metadata;\r\n\r\n    // Convert encrypted bits back to Uint8Array\r\n    const encryptedDataArray = binaryToUint8Array(encryptedBits);\r\n\r\n    // Decrypt using password, iv, and salt\r\n    const decryptedBinary = await decryptData(encryptedDataArray, password, iv, salt);\r\n\r\n    // Convert binary string back to Uint8Array\r\n    const originalBytes = binaryToUint8Array(decryptedBinary);\r\n\r\n    // Return Blob for download\r\n    return { blob: new Blob([originalBytes], { type: fileType }), fileName };\r\n}\r\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,cAAc;AAE1C,SAASC,kBAAkBA,CAACC,MAAM,EAAE;EAChC,MAAMC,KAAK,GAAG,EAAE;EAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,CAACG,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IACvCD,KAAK,CAACG,IAAI,CAACC,QAAQ,CAACL,MAAM,CAACM,KAAK,CAACJ,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACnD;EACA,OAAO,IAAIK,UAAU,CAACN,KAAK,CAAC;AAChC;AAEA,eAAe,eAAeO,UAAUA,CAACC,aAAa,EAAEC,YAAY,EAAEC,QAAQ,EAAE;EAC5E,IAAI,CAACF,aAAa,EAAE,MAAM,IAAIG,KAAK,CAAC,4BAA4B,CAAC;EACjE,IAAI,CAACF,YAAY,EAAE,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;EAC/D,IAAI,CAACD,QAAQ,IAAIA,QAAQ,CAACE,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,MAAM,IAAID,KAAK,CAAC,sBAAsB,CAAC;;EAEhF;EACA,MAAME,UAAU,GAAGJ,YAAY,CAACJ,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EAC5C,MAAMS,cAAc,GAAGV,QAAQ,CAACS,UAAU,EAAE,CAAC,CAAC;;EAE9C;EACA,MAAME,kBAAkB,GAAGN,YAAY,CAACJ,KAAK,CAAC,EAAE,EAAE,EAAE,GAAGS,cAAc,CAAC;;EAEtE;EACA,IAAIE,WAAW,GAAG,EAAE;EACpB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGc,kBAAkB,CAACb,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IACnD,MAAMgB,IAAI,GAAGF,kBAAkB,CAACV,KAAK,CAACJ,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;IAC/Ce,WAAW,IAAIE,MAAM,CAACC,YAAY,CAACf,QAAQ,CAACa,IAAI,EAAE,CAAC,CAAC,CAAC;EACzD;EAEA,MAAMG,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACN,WAAW,CAAC;EACxC,MAAM;IAAEO,EAAE;IAAEC,IAAI;IAAEC,cAAc;IAAEC,QAAQ;IAAEC;EAAS,CAAC,GAAGP,QAAQ;;EAEjE;EACA,MAAMQ,kBAAkB,GAAG9B,kBAAkB,CAACU,aAAa,CAAC;;EAE5D;EACA,MAAMqB,eAAe,GAAG,MAAMhC,WAAW,CAAC+B,kBAAkB,EAAElB,QAAQ,EAAEa,EAAE,EAAEC,IAAI,CAAC;;EAEjF;EACA,MAAMM,aAAa,GAAGhC,kBAAkB,CAAC+B,eAAe,CAAC;;EAEzD;EACA,OAAO;IAAEE,IAAI,EAAE,IAAIC,IAAI,CAAC,CAACF,aAAa,CAAC,EAAE;MAAEG,IAAI,EAAEN;IAAS,CAAC,CAAC;IAAED;EAAS,CAAC;AAC5E;AAACQ,EAAA,GAjC6B3B,UAAU;AAAA,IAAA2B,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}