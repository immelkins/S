{"ast":null,"code":"//toBinary\n//This function converts an uploaded file into a binary string representation\nimport { encryptData, decryptData } from \"./ToBlackBox\";\nexport default async function ToBinary(file, password, type) {\n  if (!file) {\n    throw new Error(\"No file provided\");\n  }\n  if (!password || password.trim() === \"\") {\n    throw new Error(\"Password is required for encryption\");\n  }\n  if (type === \"encrypt\") {\n    const arrayBuffer = await file.arrayBuffer();\n    const bytes = new Uint8Array(arrayBuffer);\n    let binary = '';\n    for (let i = 0; i < bytes.length; i++) {\n      binary += bytes[i].toString(2).padStart(8, '0');\n    }\n    const {\n      encryptedData,\n      iv,\n      salt\n    } = await encryptData(binary, password);\n    const encryptedBinary = Array.from(encryptedData).map(byte => byte.toString(2).padStart(8, '0')).join('');\n    return {\n      bits: encryptedBinary,\n      iv,\n      salt,\n      originalLength: binary.length,\n      fileName: file.name,\n      fileType: file.type\n    };\n  } else if (type === \"decrypt\") {\n    // input here is expected to be an object: { encryptedBits, iv, salt }\n    const {\n      encryptedBits,\n      iv,\n      salt\n    } = input;\n    const bytes = new Uint8Array(encryptedBits.match(/.{1,8}/g).map(b => parseInt(b, 2)));\n    const decryptedBinary = await decryptData(bytes, password, iv, salt);\n    return decryptedBinary; // this is the original binary string\n  } else {\n    throw new Error(\"Type must be 'encrypt' or 'decrypt'\");\n  }\n}\n_c = ToBinary;\nvar _c;\n$RefreshReg$(_c, \"ToBinary\");","map":{"version":3,"names":["encryptData","decryptData","ToBinary","file","password","type","Error","trim","arrayBuffer","bytes","Uint8Array","binary","i","length","toString","padStart","encryptedData","iv","salt","encryptedBinary","Array","from","map","byte","join","bits","originalLength","fileName","name","fileType","encryptedBits","input","match","b","parseInt","decryptedBinary","_c","$RefreshReg$"],"sources":["C:/Users/mesco/OneDrive/Documents/GitHub/S/src/components/ToBinary.js"],"sourcesContent":["//toBinary\r\n//This function converts an uploaded file into a binary string representation\r\nimport { encryptData, decryptData } from \"./ToBlackBox\";\r\n\r\nexport default async function ToBinary(file, password, type) {\r\n  if (!file) { throw new Error(\"No file provided\"); }\r\n  if (!password || password.trim() === \"\") { throw new Error(\"Password is required for encryption\"); }\r\n\r\n  if (type === \"encrypt\") {\r\n    const arrayBuffer = await file.arrayBuffer();\r\n    const bytes = new Uint8Array(arrayBuffer);\r\n\r\n    let binary = '';\r\n    for (let i = 0; i < bytes.length; i++) {\r\n      binary += bytes[i].toString(2).padStart(8, '0');\r\n    }\r\n\r\n    const { encryptedData, iv, salt } = await encryptData(binary, password);\r\n    const encryptedBinary = Array.from(encryptedData).map(byte => byte.toString(2).padStart(8, '0')).join('');\r\n\r\n    return {\r\n      bits: encryptedBinary,\r\n      iv,\r\n      salt,\r\n      originalLength: binary.length,\r\n      fileName: file.name,\r\n      fileType: file.type,\r\n    };\r\n  }\r\n  else if (type === \"decrypt\") {\r\n    // input here is expected to be an object: { encryptedBits, iv, salt }\r\n    const { encryptedBits, iv, salt } = input;\r\n\r\n    const bytes = new Uint8Array(encryptedBits.match(/.{1,8}/g).map(b => parseInt(b, 2)));\r\n    const decryptedBinary = await decryptData(bytes, password, iv, salt);\r\n\r\n    return decryptedBinary; // this is the original binary string\r\n  }\r\n\r\n  else { throw new Error(\"Type must be 'encrypt' or 'decrypt'\");}\r\n}"],"mappings":"AAAA;AACA;AACA,SAASA,WAAW,EAAEC,WAAW,QAAQ,cAAc;AAEvD,eAAe,eAAeC,QAAQA,CAACC,IAAI,EAAEC,QAAQ,EAAEC,IAAI,EAAE;EAC3D,IAAI,CAACF,IAAI,EAAE;IAAE,MAAM,IAAIG,KAAK,CAAC,kBAAkB,CAAC;EAAE;EAClD,IAAI,CAACF,QAAQ,IAAIA,QAAQ,CAACG,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;IAAE,MAAM,IAAID,KAAK,CAAC,qCAAqC,CAAC;EAAE;EAEnG,IAAID,IAAI,KAAK,SAAS,EAAE;IACtB,MAAMG,WAAW,GAAG,MAAML,IAAI,CAACK,WAAW,CAAC,CAAC;IAC5C,MAAMC,KAAK,GAAG,IAAIC,UAAU,CAACF,WAAW,CAAC;IAEzC,IAAIG,MAAM,GAAG,EAAE;IACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;MACrCD,MAAM,IAAIF,KAAK,CAACG,CAAC,CAAC,CAACE,QAAQ,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;IACjD;IAEA,MAAM;MAAEC,aAAa;MAAEC,EAAE;MAAEC;IAAK,CAAC,GAAG,MAAMlB,WAAW,CAACW,MAAM,EAAEP,QAAQ,CAAC;IACvE,MAAMe,eAAe,GAAGC,KAAK,CAACC,IAAI,CAACL,aAAa,CAAC,CAACM,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACT,QAAQ,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAACS,IAAI,CAAC,EAAE,CAAC;IAEzG,OAAO;MACLC,IAAI,EAAEN,eAAe;MACrBF,EAAE;MACFC,IAAI;MACJQ,cAAc,EAAEf,MAAM,CAACE,MAAM;MAC7Bc,QAAQ,EAAExB,IAAI,CAACyB,IAAI;MACnBC,QAAQ,EAAE1B,IAAI,CAACE;IACjB,CAAC;EACH,CAAC,MACI,IAAIA,IAAI,KAAK,SAAS,EAAE;IAC3B;IACA,MAAM;MAAEyB,aAAa;MAAEb,EAAE;MAAEC;IAAK,CAAC,GAAGa,KAAK;IAEzC,MAAMtB,KAAK,GAAG,IAAIC,UAAU,CAACoB,aAAa,CAACE,KAAK,CAAC,SAAS,CAAC,CAACV,GAAG,CAACW,CAAC,IAAIC,QAAQ,CAACD,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACrF,MAAME,eAAe,GAAG,MAAMlC,WAAW,CAACQ,KAAK,EAAEL,QAAQ,EAAEa,EAAE,EAAEC,IAAI,CAAC;IAEpE,OAAOiB,eAAe,CAAC,CAAC;EAC1B,CAAC,MAEI;IAAE,MAAM,IAAI7B,KAAK,CAAC,qCAAqC,CAAC;EAAC;AAChE;AAAC8B,EAAA,GApC6BlC,QAAQ;AAAA,IAAAkC,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}