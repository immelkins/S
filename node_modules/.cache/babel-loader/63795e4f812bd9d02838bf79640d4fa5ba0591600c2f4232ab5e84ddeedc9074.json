{"ast":null,"code":"// stego.js\n// Self-contained GIF steganography logic\n\nimport { parseGIF, decompressFrames } from \"gifuct-js\";\nimport ToBinary from \"./ToBinary\";\n\n/* =========================\n   ENCODE / DECODE API\n========================= */\n\nexport async function encodeFromUpload(gifFile, payloadFile, key = \"\") {\n  if (!gifFile) throw new Error(\"No GIF file provided\");\n  if (!payloadFile) throw new Error(\"No payload file provided\");\n\n  // Convert payload file → binary\n  const binaryPayload = await ToBinary(payloadFile);\n\n  // Decode GIF → frames\n  const gifBuffer = await gifFile.arrayBuffer();\n  const gif = parseGIF(gifBuffer);\n  const frames = decompressFrames(gif, true);\n\n  // Encode binary into frames\n  encodeGIF(frames, binaryPayload, key);\n  return frames;\n}\nexport async function decodeFromUpload(gifFile, key = \"\") {\n  if (!gifFile) throw new Error(\"No GIF file provided\");\n  const gifBuffer = await gifFile.arrayBuffer();\n  const gif = parseGIF(gifBuffer);\n  const frames = decompressFrames(gif, true);\n  return decodeGIF(frames, key);\n}\n\n/* =========================\n   CORE STEGO FUNCTIONS\n========================= */\n\nfunction encodeGIF(gifFrames, binaryPayload, key = \"\") {\n  if (!(gifFrames !== null && gifFrames !== void 0 && gifFrames.length)) throw new Error(\"No GIF frames provided\");\n\n  // Optional XOR encryption\n  const payload = key ? xorBinary(binaryPayload, key) : binaryPayload;\n\n  // 32-bit length header\n  const lengthHeader = payload.length.toString(2).padStart(32, \"0\");\n  const fullPayload = lengthHeader + payload;\n  let bitIndex = 0;\n  for (const frame of gifFrames) {\n    const data = frame.patch;\n    for (let i = 0; i < data.length; i += 4) {\n      if (bitIndex >= fullPayload.length) return gifFrames;\n\n      // Blue channel LSB\n      data[i + 2] = data[i + 2] & ~1 | Number(fullPayload[bitIndex]);\n      bitIndex++;\n    }\n  }\n  if (bitIndex < fullPayload.length) {\n    console.warn(\"Payload truncated: GIF too small\");\n  }\n  return gifFrames;\n}\nfunction decodeGIF(gifFrames, key = \"\") {\n  if (!(gifFrames !== null && gifFrames !== void 0 && gifFrames.length)) throw new Error(\"No GIF frames provided\");\n  let bits = \"\";\n  for (const frame of gifFrames) {\n    const data = frame.patch;\n    for (let i = 0; i < data.length; i += 4) {\n      bits += (data[i + 2] & 1).toString();\n    }\n  }\n\n  // First 32 bits = payload length\n  const payloadLength = parseInt(bits.slice(0, 32), 2);\n  let payload = bits.slice(32, 32 + payloadLength);\n  if (key) {\n    payload = xorBinary(payload, key);\n  }\n  return payload;\n}\n\n/* =========================\n   HELPERS\n========================= */\n\nfunction xorBinary(binary, key) {\n  const keyBinary = stringToBinary(key);\n  let result = \"\";\n  for (let i = 0; i < binary.length; i++) {\n    result += binary[i] ^ keyBinary[i % keyBinary.length];\n  }\n  return result;\n}\nfunction stringToBinary(str) {\n  return Array.from(str).map(c => c.charCodeAt(0).toString(2).padStart(8, \"0\")).join(\"\");\n}","map":{"version":3,"names":["parseGIF","decompressFrames","ToBinary","encodeFromUpload","gifFile","payloadFile","key","Error","binaryPayload","gifBuffer","arrayBuffer","gif","frames","encodeGIF","decodeFromUpload","decodeGIF","gifFrames","length","payload","xorBinary","lengthHeader","toString","padStart","fullPayload","bitIndex","frame","data","patch","i","Number","console","warn","bits","payloadLength","parseInt","slice","binary","keyBinary","stringToBinary","result","str","Array","from","map","c","charCodeAt","join"],"sources":["/Users/melvinescobar/Steganography/src/components/Stego.js"],"sourcesContent":["// stego.js\n// Self-contained GIF steganography logic\n\nimport { parseGIF, decompressFrames } from \"gifuct-js\";\nimport ToBinary from \"./ToBinary\";\n\n/* =========================\n   ENCODE / DECODE API\n========================= */\n\nexport async function encodeFromUpload(gifFile, payloadFile, key = \"\") {\n  if (!gifFile) throw new Error(\"No GIF file provided\");\n  if (!payloadFile) throw new Error(\"No payload file provided\");\n\n  // Convert payload file → binary\n  const binaryPayload = await ToBinary(payloadFile);\n\n  // Decode GIF → frames\n  const gifBuffer = await gifFile.arrayBuffer();\n  const gif = parseGIF(gifBuffer);\n  const frames = decompressFrames(gif, true);\n\n  // Encode binary into frames\n  encodeGIF(frames, binaryPayload, key);\n\n  return frames;\n}\n\nexport async function decodeFromUpload(gifFile, key = \"\") {\n  if (!gifFile) throw new Error(\"No GIF file provided\");\n\n  const gifBuffer = await gifFile.arrayBuffer();\n  const gif = parseGIF(gifBuffer);\n  const frames = decompressFrames(gif, true);\n\n  return decodeGIF(frames, key);\n}\n\n/* =========================\n   CORE STEGO FUNCTIONS\n========================= */\n\nfunction encodeGIF(gifFrames, binaryPayload, key = \"\") {\n  if (!gifFrames?.length) throw new Error(\"No GIF frames provided\");\n\n  // Optional XOR encryption\n  const payload = key ? xorBinary(binaryPayload, key) : binaryPayload;\n\n  // 32-bit length header\n  const lengthHeader = payload.length\n    .toString(2)\n    .padStart(32, \"0\");\n\n  const fullPayload = lengthHeader + payload;\n\n  let bitIndex = 0;\n\n  for (const frame of gifFrames) {\n    const data = frame.patch;\n\n    for (let i = 0; i < data.length; i += 4) {\n      if (bitIndex >= fullPayload.length) return gifFrames;\n\n      // Blue channel LSB\n      data[i + 2] = (data[i + 2] & ~1) | Number(fullPayload[bitIndex]);\n      bitIndex++;\n    }\n  }\n\n  if (bitIndex < fullPayload.length) {\n    console.warn(\"Payload truncated: GIF too small\");\n  }\n\n  return gifFrames;\n}\n\nfunction decodeGIF(gifFrames, key = \"\") {\n  if (!gifFrames?.length) throw new Error(\"No GIF frames provided\");\n\n  let bits = \"\";\n\n  for (const frame of gifFrames) {\n    const data = frame.patch;\n\n    for (let i = 0; i < data.length; i += 4) {\n      bits += (data[i + 2] & 1).toString();\n    }\n  }\n\n  // First 32 bits = payload length\n  const payloadLength = parseInt(bits.slice(0, 32), 2);\n  let payload = bits.slice(32, 32 + payloadLength);\n\n  if (key) {\n    payload = xorBinary(payload, key);\n  }\n\n  return payload;\n}\n\n/* =========================\n   HELPERS\n========================= */\n\nfunction xorBinary(binary, key) {\n  const keyBinary = stringToBinary(key);\n  let result = \"\";\n\n  for (let i = 0; i < binary.length; i++) {\n    result += binary[i] ^ keyBinary[i % keyBinary.length];\n  }\n\n  return result;\n}\n\nfunction stringToBinary(str) {\n  return Array.from(str)\n    .map(c => c.charCodeAt(0).toString(2).padStart(8, \"0\"))\n    .join(\"\");\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}